#!/bin/bash
########################################################################################
## @file	ansible_engine.sh
## @brief       -THE- GUI for using ansible + splunk
## @author	Thomas Fischer <mail -AT- sedi -DOT- one>
## @date        2017-2019
## @copyright	GPL v3
## @details     
##    This program is free software: you can redistribute it and/or modify<br>
##    it under the terms of the GNU General Public License as published by<br>
##    the Free Software Foundation, either version 3 of the License, or<br>
##    (at your option) any later version.<br>
##    <br>
##    This program is distributed in the hope that it will be useful,<br>
##    but WITHOUT ANY WARRANTY; without even the implied warranty of<br>
##    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<br>
##    GNU General Public License for more details.<br>
##    <br>
##    You should have received a copy of the GNU General Public License<br>
##    along with this program.  If not, see <http://www.gnu.org/licenses/>.
##
########################################################################################
#
## @mainpage ansible engine (ae)
## @section intro Overview
## ansible engine (ae) is a wrapper and GUI (ncurses/dialog based) to execute several tasks with ansible.<br>
## This is a pure **technical** documentation of ae for those who want to understand how ae works under the hood
##
## @section code Code
## ansible engine is hosted at github:<br>
## https://github.com/secure-diversITy/ansible_engine
## 
## @section secintro User documentation
## The ansible engine (ae) configuration and installation is described here: <br>
## https://github.com/secure-diversITy/ansible_engine/wiki
##<br>
###############################################################################################################
VERSIONTYPE=stable
VERSIONNUM="3.2-1"
VERSION="${VERSIONNUM}-${VERSIONTYPE}"
###############################################################################################################
#
# This script is automatically documented by doxygen (http://doxygen.nl)
#
# There are a few things you have to do so though:
# - every var must be exported or declared to get identified properly
# - every function must start like that: "<name>(){ <EOL>" 
#   So func name, brackets and { must be all in the same line and you have to start code at the next line first.
# - bash advanced if-var-empty syntax like: ': "${DEFSPLAPIADMIN:=admin}"' won't get detected, 
#   use test -z and declare instead
#
# doxygen copy templates:
#
# # @var 
# # @brief 
# # @details 
#
# # @fn F_NAME()
# # @brief ..
# # @param 1 ..
# # @return ..
# # @exception ..
# # @details ..
##############################################################################################################

# source an variable overwrite if available
[ -f ${HOME}/.ae/vars ] && source ${HOME}/.ae/vars

## @var RUNMODE
## @brief ae can run in several modes this sets the default
## @showinitializer
## @details There is *no* (!) need to touch this as it will be adjusted depending
## on the parameters how ae is started (e.g. --batch will set batch mode)
export RUNMODE="interactive"

## @var PYTHONUNBUFFERED
## @brief avoid buffering when exec python code (ansible)
## @showinitializer
## @details when python buffers output ae seems to hang until the 
## whole playbook has been finished without any feedback. This ensures we see output directly in ae.
export PYTHONUNBUFFERED=1

## @var BIN
## @brief auto generate the binary name without path
## @showinitializer
declare BIN=${0##*/}


## @var REQAVERSION
## @brief The minimal required Ansible version
## @details the version string in the format: X.x.x
## @showinitializer
declare REQAVERSION="2.8.0"

# ensure we run in a proper environment
if [ -z "$CALLUSR" ];then
    MYHOME=${HOME}/.$(echo ${BIN/.sh}|tr -d _)
else
    MYHOME=/tmp/ae-${CALLUSR}
fi

## @var WORKDIR
## @brief The working directory where all run files of ae will be stored
## @details Every user running AE has its own temp directory accessible only by the AE user
## @showinitializer
declare WORKDIR="$MYHOME"
[ ! -d "$WORKDIR" ]&& mkdir -p $WORKDIR
chown $USER $WORKDIR
chmod 700 $WORKDIR  

## @var ADIR
## @brief auto generate the path name of the bin
## @showinitializer
## @details the ae install dir. can be overwritten in ~/.ae/vars 
[ -z "$ADIR" ] && \
declare ADIR="${0%/*}"

# the path where your inventories (with their subdirs like development, production) are in
: "${AINVENTORY:=$ADIR/inventories}"

## @var KICKUSER
## @brief Default setting for overtaken a running session
## @showinitializer
## @details normally we want to have 1 instance running the same time. This avoids dozens of problems which could occur.
## The default when pressing just enter can be y (remove and take the lock) or N (quit)
declare KICKUSER=N

## @var EXECBIT
## @brief execution lock file
## @showinitializer
## @details A simple lock file to detect an already running AE session
declare EXECBIT=/tmp/.ae_inuse

## @var ABIN
## @brief The full path to the regular ansible playbook binary
## @showinitializer
declare ABIN="/usr/bin/ansible-playbook"

# if you want you can run another ansible version by specifying the A2xx vars:
: "${A2PATH:=/opt/splunk/ansible-git}"
: "${A2BIN:=$A2PATH/bin/ansible-playbook}"

## @var LOG
## @brief The ae log file
## @showinitializer
declare LOG=${WORKDIR}/${BIN}.log

## @var AEUSRHOSTFILE
## @brief the user choosen hostfile will be written into this file
## @details can be sourced like: source $AEUSRHOSTFILE - will set HOSTFILE=
## @showinitializer
declare AEUSRHOSTFILE=${WORKDIR}/ae_current_hostfile

## @var EDITBIN
## @brief The editor which will be used e.g. when editing system/local files
## @details Can be overwritten by ~/.ae/vars
## @showinitializer
[ -z "$EDITBIN" ] && \
declare EDITBIN=/usr/bin/vim

## @var PBDIR
## @brief The directory where all playbooks are expected
## @details Can be overwritten by ~/.ae/vars
## @showinitializer
[ -z "$PBDIR" ] && \
declare PBDIR="$ADIR"

## @var ROLEDIR
## @brief The directory where all roles are expected
## @details Can be overwritten by ~/.ae/vars
## @showinitializer
[ -z "$ROLEDIR" ] && \
declare ROLEDIR="$PBDIR/roles"

## @var PBENAPP
## @brief Adding/Linking new app(s) to ae
## @showinitializer
declare PBENAPP=${PBDIR}/ae_enable_app.yml

## @var PBREGENDEPLOY
## @brief Regenerate ae_deploy_apps.yml
## @showinitializer
## @details This playbook generates $PBDEPLAPP based on the linked apps<-->targets
declare PBREGENDEPLOY=${PBDIR}/ae_recreate_deploy.yml

## @var PBDEPLAPP
## @brief Deploy apps to given targets
## @showinitializer
## @details This playbook gets autogenerated when running $PBREGENDEPLOY
declare PBDEPLAPP=ae_deploy_apps.yml

## @var PBDEPLSYSC
## @brief Deploy system/local configs to given targets 
## @showinitializer
declare PBDEPLSYSC=${PBDIR}/ae_deploy_systemconfigs.yml

## @var PBGETTARGETS
## @brief Parsing inventories file and create an expanded host list for each target
## @showinitializer
declare PBGETTARGETS=${PBDIR}/ae_get_targets.yml

## @var PBUPGRADE
## @brief Upgrade splunk
## @showinitializer
declare PBUPGRADE=${PBDIR}/ae_upgrade_splunk.yml

## @var  PBSHINSTALL
## @brief Install/Upgrade the splunk helper
## @details https://github.com/secure-diversITy/splunk/tree/master/splunkhelper
## @showinitializer
declare PBSHINSTALL=${PBDIR}/ae_install_shelper.yml

## @var SHOWAPPS
## @brief Show app deployment state by target(s) and type (local, git, ...)
## @showinitializer
declare SHOWAPPS=${PBDIR}/ae_show_app_deploymentstate.sh

## @var PBSHRELOAD
## @brief Execute splunk helper tasks
## @details https://github.com/secure-diversITy/splunk/tree/master/splunkhelper
## @showinitializer
declare PBSHRELOAD=${PBDIR}/maintenance/ae_shelper_reload.yml

## @var PBSPLACT
## @brief Maintenance tasks for splunk
## @details Examples: splunk stop, start, restart
## @showinitializer
declare PBSPLACT=${PBDIR}/maintenance/ae_splunk_tasks.yml

## @var PBINSTALL
## @brief Install splunk
## @details Will install splunk on a single host or group of hosts
## @showinitializer
declare PBINSTALL=${PBDIR}/ae_install_splunk.yml

## @var PBCONFMN
## @brief Configures splunk as a master node
## @details This will configure an existing splunk installation as a MasterNode for a new cluster
## @showinitializer
declare PBCONFMN=${PBDIR}/ae_configure_masternode.yml

## @var PBCONFPEER
## @brief Configures splunk as a peernode 
## @details This will configure an existing splunk installation as a peernode of an existing indexer cluster
## @showinitializer
declare PBCONFPEER=${PBDIR}/ae_configure_ix_peernode.yml

## @var PBCONFSH
## @brief Configures splunk as a searchhead
## @details This will configure an existing splunk installation as a SearchHead
## @showinitializer
declare PBCONFSH=${PBDIR}/ae_configure_searchhead.yml

## @var PBCONFHF
## @brief Configures splunk as a heavy forwarder
## @details This will configure an existing splunk installation as a Heavy Forwarder
## @showinitializer
declare PBCONFHF=${PBDIR}/ae_configure_heavyforwarder.yml

## @var INSTDEF
## @brief splunk installation conf
## @details Used to configure several splunk installation relevant stuff like tgz/rpm/version etc
## @showinitializer
declare INSTDEF=splunk_installation

## @var PBDLSPL
## @brief Downloader for splunk tar's
## @details Will download a defined splunk release (hard coded type: linux/64bit/tar.gz) directly from splunk
## @showinitializer
declare PBDLSPL=${PBDIR}/ae_download_splunk.yml 

## @var PBVCINFO
## @brief Collecting vCenter information
## @details Will connect to a vCenter and grabs all relevant information for VM deployment
## @showinitializer
declare PBVCINFO="${PBDIR}/vmware/vcenter_get-info.yml"

## @var PBVCVMDEPLOY
## @brief Deploys a VM over a given vCenter to a ESX host
## @details Will connect to a vCenter and deploys a new VM to it (based on a given template)
## @showinitializer
declare PBVCVMDEPLOY="${PBDIR}/vmware/vcenter_deploy-vm.yml"

## @var PBVCSHOW
## @brief Parse and show all local defined vCenters
## @details vCenter definitions are taken in:
## $INVENTORY/$TARGETENV/group_vars/all/bare_install
## The playbook $PBVCSHOW will parse and write the results to a tmp file defined in $PBVCSHOW
## @showinitializer
declare PBVCSHOW="${PBDIR}/vmware/vcenter_show-avail.yml"

## @var PBVMNEWDISK
## @brief Add an additional disk to an existing VM
## @details ..
## @showinitializer
declare PBVMNEWDISK="${PBDIR}/ae_vm_add-new-disk.yml"

## @var PBVMDISKFORMAT
## @brief Formatting a given disk in a VM
## @details ..
## @showinitializer
declare PBVMDISKFORMAT="${PBDIR}/ae_vm_format-new-disk.yml"

## @var PBSYSYUM
## @brief Execute yum tasks
## @details El-Repo kernel and system upgrades are just 2 examples here
## @showinitializer
declare PBSYSYUM="${PBDIR}/ae_system_yum.yml"

## @var PBSSHCHK
## @brief Initial SSH connect
## @details Will add the host key when none exists yet. Add will be skipped when a host key changed!
## @showinitializer
declare PBSSHCHK="${PBDIR}/ae_ssh.yml"

## @var DEFSPLAPIADMIN
## @brief default splunk API (target:8089) admin account
## @details Defaults to "admin" user and can be changed interactively in AE when asked.
## Do not change it here, for this define AEUSER in {HOME}/.ae/vars instead
## This account needs privileges to run API calls so either the admin or an user with at least the following capabilities (not tested and so maybe incomplete):
## - rest_apps_view
## - rest_properties_get
## - rest_properties_set
## - restart_splunkd
## @showinitializer
#: "${DEFSPLAPIADMIN:=admin}"
[ -z "$DEFSPLAPIADMIN" ] && \
declare DEFSPLAPIADMIN=admin

## @var DEFHOSTFILE
## @brief default filename for host/group definitions in ansible
## @details Defaults to "hosts" and can be changed interactively in AE when asked.
## Do not change it here, for this define AEUSER in {HOME}/.ae/vars instead
## @showinitializer
#: "${DEFHOSTFILE:=hosts}"
[ -z "$DEFHOSTFILE" ] && \
declare DEFHOSTFILE=hosts

## @var GLABSETTINGS
## @brief gitlab authentication file
## @details stores the gitlab token for communicationg with gitlab API
## Do not change it here, for this define AEUSER in {HOME}/.ae/vars instead
## @showinitializer
[ -f "${HOME}/.ae/gitlab.auth" ] && GLABSETTINGS="${HOME}/.ae/gitlab.auth"
#: "${GLABSETTINGS:=$WORKDIR/gitlab.auth}"
[ -z "$GLABSETTINGS" ] && \
declare GLABSETTINGS="$WORKDIR/gitlab.auth"

## @var AEUSER
## @brief local username for running AE
## @details Defaults to "splunk" as it is meant for multi-user environments to keep track of actions in AE. 
## Do not change it here, for this define AEUSER in {HOME}/.ae/vars instead
## @showinitializer
#: "${AEUSER:=splunk}"
[ -z "$AEUSER" ] && \
declare AEUSER=splunk

## @var ENABLEVAULT
## @brief Make use of the Ansible Vault
## @details When set to "yes" AE will ask for the Vault password on certain actions
## hint: to operate seamless the typed password gets stored locally but only until the cookie authentication has finished.
## after that the temporary file gets deleted automatically.
## If you are scared about storing a password even temporary do not enable this functionality.
## @showinitializer
declare ENABLEVAULT=yes

## @var SESSIONBASEDVAULT
## @brief Store the Ansible Vault temp file for the whole session
## @details When set to "yes" AE will not remove the temporary Vault password (req: ENABLEVAULT=yes)
## for the whole session (less questions but less secure).
## If you are scared about storing a password even temporary do not enable this functionality.
## @showinitializer
declare SESSIONBASEDVAULT=yes

#################################################################################################
# NO CHANGES BEHIND THIS POINT | NO CHANGES BEHIND THIS POINT | NO CHANGES BEHIND THIS POINT 
#################################################################################################


## @var VAULTTEMPFILE
## @brief The temporary file holding the Ansible Vault password
## @details Only relevant if ENABLEVAULT is set to yes.
## to operate seamless the typed password gets stored locally but only until the cookie authentication has finished.
## after that the temporary file gets deleted automatically.
## If you are scared about storing a password even temporary do *not* set ENABLEVAULT=yes .
## The temporary file is placed in WORKDIR which is accessible by the AE user only!
declare VAULTTEMPFILE="${WORKDIR}/.avtmp"

unset A2VAULTARG
[ "$ENABLEVAULT" == "yes" ] && declare A2VAULTARG="--vault-password-file $VAULTTEMPFILE" && declare ABIN="$ABIN ${A2VAULTARG}"


## @fn F_LOG()
## @brief Logging function
## @param 1 (required) the calling parent function
## @param 2 (required) the message to be logged
## @details Logging function
F_LOG(){
	CALLER="$1"
	MSG="$2"
	if [ -z "$MSG" ]||[ -z "$CALLER" ];then
		F_DIAERR 2 "INTERNAL ERROR: $FUNCNAME requires an arg"
	else
		PREFIX="$(date '+%F_%T') ($CALLER) -"
		echo -e "$PREFIX $MSG" >> $LOG
	fi
}

## @fn F_RMVAULTPW()
## @brief removes the temporary Ansible Vault pw file
## @param 1 (optional) force/override SESSIONBASEDVAULT setting
## @details Checks for $VAULTTEMPFILE and if that exists it gets deleted.
## This should be used whenever F_VAULTPW was used before.
F_RMVAULTPW(){
    F_LOG $FUNCNAME started
    if [ -f "$VAULTTEMPFILE" ];then
        [ "$1" == "force" ] && F_LOG $FUNCNAME "deleting vault temp file - forced" && rm $VAULTTEMPFILE && return 0
        [ "$SESSIONBASEDVAULT" != "yes" ] && F_LOG $FUNCNAME "deleting vault temp file - regular" && rm $VAULTTEMPFILE && return 0
        [ "$SESSIONBASEDVAULT" == "yes" ] && F_LOG $FUNCNAME "skipped removing vault temp file" && return 0
        F_LOG $FUNCNAME "deleting vault temp file - no SESSIONBASEDVAULT" && rm $VAULTTEMPFILE
    fi
    F_LOG $FUNCNAME ended
}

## @fn F_ENDSESS()
## @brief Clear ae session
## @details ae ensures it will not be executed more then 1 time by the EXECBIT var
F_ENDSESS(){
    F_LOG $FUNCNAME started
        F_RMVAULTPW force
	F_LOG $FUNCNAME "deleting session file:"
    rm -vf $EXECBIT 2>&1 >> $LOG
	F_LOG $FUNCNAME ended
}

## @fn F_EXIT()
## @brief regular AE exit
## @details clean exit including clearing the session bit
F_EXIT(){
    F_LOG $FUNCNAME started
        ERRCODE=$1

	F_ENDSESS
	# finally terminate
    F_LOG $FUNCNAME "ended $ERRCODE" 
	exit $ERRCODE
}

## @fn F_EXITUNCLEAN()
## @brief exit the program unclean but controlled
## @param 1 optional: exit code (default 0)
## @details will not clear the session bit so only needed in rare cases (e.g. --help)
F_EXITUNCLEAN(){
    F_LOG $FUNCNAME started
    ERRCODE=$1
    echo "$FUNCNAME: No session exit" >> $LOG
    F_LOG $FUNCNAME "ended $ERRCODE"
    #trap - SIGINT SIGHUP TERM
    exit $ERRCODE
}

# catch ctrl+c, kills etc to terminate cleanly..
trap F_EXIT SIGINT SIGHUP TERM

# check requirements first
dialog --version >> /dev/null 2>&1
if [ $? -ne 0 ];then
	echo -e "\nplease install the software <dialog> first!\n"
else
    $ABIN --version >> /dev/null 2>&1
    if [ $? -ne 0 ];then
        echo -e "\nReally?? You want to use ansible deployment without ansible??! Coooool.. Install ansible and try again..\n"
	export ERRCODE=90
        F_EXIT
    fi
    for i in $(echo $SHOWAPPS $PBNEWAPP $PBENAPP $PBDEPLSYSC);do
	if [ ! -r $i ];then 
	    echo -e "\n\tERROR. Please ensure you've done chmod +r $i first and that $i exists!\n"
	    F_EXIT
	fi
    done
fi

## @fn F_A2BIN()
## @brief start ansible v2 (instead of PATH bin)
## @param 1 (required) the ansible hostfile or the special "version" tag
## @param 2 (required) the ansible playbook
## @param 3 (required) the title for the progressbox of the playbook run
## @param 4 (optional) ansible extra args. space separated parameters like -e 'var1=moo var2=cow' need to be defined in JSON format<br>
## @details start A2BIN. takes all args without any proof / verification!
## TODO: parse args and do a basic validation?!<br>
## example args: F_A2BIN hosts myplaybook myboxtitle "-e {'var1':'moo','var2':'cow'}"
F_A2BIN(){
        F_LOG $FUNCNAME started
	# returns error code of the playbook run
	#
	# requires these parameters:
	A2HOSTFILE="$1" # the ansible hostfile or the special "version" tag
	A2PB="$2"	# the ansible playbook
	BOXTITLE="$3"	# the title for the progressbox of the playbook run

	# optional:
	# ansible extra args. space separated parameters like -e 'var1=moo var2=cow' need to be defined in JSON format!!
	# e.g.: F_A2BIN hosts myplaybook myboxtitle "-e {'var1':'moo','var2':'cow'}"
	A2ARGSRAW="$4"	

	F_LOG $FUNCNAME "ARGSRAW: $A2ARGSRAW"
	
	# find space keyword
	A2ARGS=$(echo "$A2ARGSRAW" | sed 's/SPACE/ /g')
	F_LOG $FUNCNAME "ARGS: $A2ARGS"
	
	if [ -z "$A2HOSTFILE" ]||[ -z "$A2PB" ]||[ ! -f "$A2HOSTFILE" ]||[ ! -f "$A2PB" ];then
            if [ "$A2HOSTFILE" != "version" ];then
	        if [ "$RUNMODE" == "batch" ];then
                    echo "ERROR: Missing or wrong ARGS in $FUNCNAME (A2HOSTFILE:$A2HOSTFILE,A2PB:$A2PB)!"
                    return 1
                else
                    F_DIAERR 3 "INTERNAL ERROR: Missing or wrong ARGS for $FUNCNAME (A2HOSTFILE:$A2HOSTFILE,A2PB:$A2PB)"
                fi
	        F_EXIT $FUNCNAME 3
            fi
	fi

	F_LOG $FUNCNAME "$A2BIN -i $A2HOSTFILE ${A2ARGS} $A2PB"
        OLDPP="$PYTHONPATH"
	F_LOG $FUNCNAME "python path before: $OLDPP"
	export PYTHONPATH=${A2PATH}/lib
	F_LOG $FUNCNAME "python path after: $PYTHONPATH"
        if [ "$A2HOSTFILE" == "version" ];then
            $A2BIN --version
        else
            if [ "$RUNMODE" == "interactive" ];then
                [ ! -s $VAULTTEMPFILE ] && [ "$ENABLEVAULT" == "yes" ] && F_VAULTPW
	        $A2BIN -i $A2HOSTFILE $A2PB ${A2ARGS} ${A2VAULTARG} 2>&1 | tee -a $LOG | sed -u -r 's/(.*DEPRECATION.*)//Ig' | F_DIALOG --scrollbar --colors --progressbox "$BOXTITLE" 1000 1000
	        A2ERR="${PIPESTATUS[0]}"
            else
                $A2BIN -i $A2HOSTFILE $A2PB ${A2ARGS} ${A2VAULTARG} 2>&1 | tee -a $LOG
	        A2ERR="${PIPESTATUS[0]}"
            fi
        fi
        export PYTHONPATH="$OLDPP"
        F_LOG $FUNCNAME "previous python path restored: $PYTHONPATH"
	F_LOG $FUNCNAME "finished with errcode $A2ERR"
	return $A2ERR
}

# main dialog form
F_DIALOG(){
    if [ "$RUNMODE" == "interactive" ];then
	    dialog --no-mouse --title "ae for splunk> v$VERSION/$MAXAVERSION (${TARGETENV})" "$@"
    else
        echo "$@"
    fi
}

# really? you want to read a comment for this function?
F_HELP(){
	echo
	echo -e "    USAGE/HELP for $BIN (v$VERSION)"
	echo
	echo -e "    Interactive / GUI mode:\n    ------------------------------------------"
    echo -e "    The regular way of using ae\n"
	echo -e "\t--env <environment>\t\t\tdefine the running environment ($AINVENTORY/[your --env setting]/, e.g. production or development, ...)"
	echo -e "\t--help\t\t\t\t\tWill show this\n"
	echo -e "\t--advanced\t\t\t\tWill enable/show advanced option menu"
	echo -e "\t--testing\t\t\t\tUnfinished menu options"
	echo -e "\t-i|--inventory <hosts-file>\t\tThe full path to your hosts filename"
	echo -e "\n\n    Batch / API mode: !!!WORK-IN-PROGRESS!!!\n    ------------------------------------------"
    echo -e "    Enables full automated way of using ae\n"
	echo -e "\t--batch"
	echo -e "\n\t  mandatory:"
	echo -e "\t    --env <environment>\t\t\tdefine the running environment ($AINVENTORY/[your --env setting]/, e.g. production or development, ...)"
	echo -e "\t    -i|--inventory <hosts-file>\t\tThe full path to your hosts filename"
	echo -e "\t    -t|--target <targetgroup>\t\tThe group name as defined in your inventory"
    echo -e "\n\t  Action OR Play:"
	echo -e "\t    -p|--play <playbookname>\t\tavailable playbooks are in $ADIR"
    echo -e "\t   OR" 
	echo -e "\t    -a|--action <predefined action>\tcurrent predefined actions are: deploy"
	echo -e "\n\t  optional:"
	echo -e "\t    -1\t\t\t\t\twill force to use ansible v1 as v2 is default"
	echo -e "\t    --deployapp \"<app name(s)>\"\t\tQUOTED list separated by a PIPE (|) of app names to deploy - if you do *not* want to deploy ALL apps for a target!"
	echo -e "\t\t\t\t\t\tThis quoted list is egrep regex so may match unwanted things if not being careful."
	echo -e "\t\t\t\t\t\tExample:\n\t\t\t\t\t\tIf you set --deployapp \"my-app|my-other-app\" it will match my-app and my-other-app - but also my-app-bla, my-apps, etc"
	echo -e "\t\t\t\t\t\tIf you want to ensure that only the name \"my-app\" matches use the $ char at the end: like --deployapp \"my-app$|my-other-app\""
	echo -e "\n"
}

## @fn F_SHOWAPPS()
## @brief Deprecated way of parsing and showing apps<->target
## @param 1 The target group to parse for
## @return a list of all apps linked to the target
## @exception if env cant be found
## @details This is superseeded by F_LISTAPPS and should not be used anymore
F_SHOWAPPS(){
	echo "$FUNCNAME started" >> $LOG
	SEL="$1"
	[ -z "$SEL" ]&& echo ERROR missing arg for F_SHOWAPPS
	if [ "$SEL" == "ALL" ];then
		$SHOWAPPS -env $AINVENTORY/$TARGETENV
	else
		$SHOWAPPS -env $AINVENTORY/$TARGETENV "$SEL"
	fi
	echo "************************************************"
	read -p "To continue press ENTER" DUMMY
	echo "$FUNCNAME finished" >> $LOG
}

## @fn F_LISTAPPS()
## @brief Parse and show apps<->target links
## @param 1 The target group to parse for
## @return a list of all apps linked to the target in the format: "type:app-name"
## @exception if env cant be found
## @details $SHOWAPPS is able to handle one or multiple targets at the same time
F_LISTAPPS(){
        F_LOG $FUNCNAME started
        SEL="$1"
        [ -z "$SEL" ]&& echo "ERROR:missing arg for $FUNCNAME"
        if [ "$SEL" == "ALL" ];then
                $SHOWAPPS -batch -env $AINVENTORY/$TARGETENV
        else
                $SHOWAPPS -batch -env $AINVENTORY/$TARGETENV "$SEL"
        fi
        F_LOG $FUNCNAME ended
}

## @fn F_RMAPP()
## @brief Removes an app <--> target linkage
## @exception abort by user/error on unlinking
## @details Removes an app <--> target linkage
## 1. ask for complete removal or just unlink
## 2. ask for target group
## 3. offer multi checkbox list of all apps for that group
F_RMAPP(){
    F_LOG $FUNCNAME started

    unset SELECTION RMAPPS ABORTED HOSTSELECT HOSTSELECTION
    F_HOSTFILE

    SELECTION=$(F_DIALOG --radiolist "You have to choose an action mode first\n\nThe following will be choosen for ALL apps you will select in the next steps.\n(You can *not* use both modes in the same run)\n\n" 15 150 16 "Remove" "Will completely delete apps (local *AND* on remote)" "on" "Disable" "Will keep the link but disables app from ae deployment (will *not* touch remote)" "off" "Unlink" "Will completely unlink the apps (will *not* touch remote)" "off" 2>&1 >/dev/tty)
    [ $? -ne 0 ] && F_LOG $FUNCNAME "aborted by user" && return 4

    while [ -z "$HOSTSELECT" ];do
        HOSTSELECTION=$(F_TARGETS radiolist)
        [ $HOSTSELECTION == "ABORTED" ] && ABORTED=1 && return 4
        if [ -z "$HOSTSELECTION" ];then
            F_DIALOG --msgbox "ERROR: no selection made. Choose 1 or more targets with space bar." 10 30
        else
            HOSTSELECT=1
            ABORTED=0
        fi
    done
    if [ "$ABORTED" -ne 0 ];then
        F_LOG $FUNCNAME "DEBUG: aborted by user."
        return 4
    fi

    F_LOG $FUNCNAME "Choosen target group: $HOSTSELECTION"
    OPTIONS=($(for i in $(F_LISTAPPS "$HOSTSELECTION" |cut -d ":" -f 1-2);do echo "${i/*:}" "${i/:*}" off;done))
    RMAPPS=$(F_DIALOG --checklist "\nPlease use the space-bar to make your selection:" 80 80 70 "${OPTIONS[@]}" 2>&1 >/dev/tty)
    [ $? -ne 0 ] && F_LOG $FUNCNAME "aborted by user" && return 4

    F_LOG $FUNCNAME "choosen apps for deletion: $RMAPPS"
    
    # in any case disable the app locally
    for app in $RMAPPS;do
        sed -i "s/\(^\s*\)\(install:\s*[Tt]rue\)/\1install: false/g" $AINVENTORY/$TARGETENV/group_vars/$HOSTSELECTION/$app 2>> $LOG
    done

    case $SELECTION in
        Remove)
           for app in $RMAPPS;do
                # ensure migrated linked apps can be handled properly on the next step
                egrep "\s*delete:" $AINVENTORY/$TARGETENV/group_vars/$HOSTSELECTION/$app || echo "    delete: false" >> $AINVENTORY/$TARGETENV/group_vars/$HOSTSELECTION/$app 
                # set removal flag
                sed -i "s/\(^\s*\)\(delete:\s*[Ff]alse\)/\1delete: true/g" $AINVENTORY/$TARGETENV/group_vars/$HOSTSELECTION/$app 2>> $LOG
            done
            F_DIALOG --yesno "\nDo you want to remove the choosen apps now?\n(otherwise this will just happen on next deployment run)\n\nThis will delete theses apps on $HOSTSELECTION:\n\n$RMAPPS" 15 80 
            [ $? -ne 0 ] && F_LOG $FUNCNAME "aborted by user" && return 4

            export SHOSTFILE=$HOSTFILE
            export BTARGET="$HOSTSELECTION"
            F_DEPLOYAPP auto
        ;;
        Disable)
            F_LOG $FUNCNAME "app has been disabled"
        ;;
        Unlink)
            for app in $RMAPPS;do
                rm -vf $AINVENTORY/$TARGETENV/group_vars/$HOSTSELECTION/$app 2>&1 >> $LOG
            done
        ;;
    esac

    F_LOG $FUNCNAME ended
}

# do you wanna see all or choose
F_SELECTOR(){
	echo "$FUNCNAME started" >> $LOG
	SELECTION=$(F_DIALOG --menu "\nChoose an option:" \
			15 76 14 \
			Choose "" \
			ALL "" \
			3>&1 1>&2 2>&3)
	echo "$SELECTION"
	echo "$FUNCNAME finished" >> $LOG
}

# show current apps deployment
F_GOAPPS(){
	echo "$FUNCNAME started" >> $LOG
	if [ "$SELECTION" == "ALL" ];then
		F_SHOWAPPS "ALL"
	else
		if [ "$SELECTION" == "Choose" ];then
			OPTIONS=($(for i in $(find $AINVENTORY/$TARGETENV/group_vars/* -maxdepth 1 -type d |egrep -v "(templates|all)" |sed s#$AINVENTORY/$TARGETENV/group_vars/##g);do echo $i $i off;done))
			SELECTION=$(F_DIALOG --checklist "Select options:" 22 76 16 "${OPTIONS[@]}" 2>&1 >/dev/tty)
			if [ -z "$SELECTION" ];then
			F_DIALOG --msgbox "ERROR: no selection made. Choose 1 or more targets with space bar." 10 30 
			else
				F_SHOWAPPS "$SELECTION"
			fi
		else
			echo ERROR no selection made 
		fi
	fi
	echo "$FUNCNAME finished" >> $LOG
}

## @fn F_HOSTFILE()
## @brief Choose / check ansible inventory file
## @param 1 optional: mode (auto|\<empty\>)
## mode auto: will set hostfile by $SHOSTFILE variable
## @details
## ask for hosts filename (will list any hosts.* files as well)
## returns either the hostfile or ABORTED if the user cancels
F_HOSTFILE(){
	F_LOG $FUNCNAME started
	STARTOVER=1
	ABORT=0
    FMODE=$1

    if [ ! -z "$FORCEDHOSTFILE" ];then
         HOSTFILE="$FORCEDHOSTFILE"
    elif [ "$FMODE" == "auto" ];then
        HOSTFILE="$SHOSTFILE"
    elif  [ "$RUNMODE" == "batch" ];then
        HOSTFILE="$SHOSTFILE"
    else
	  while [ $STARTOVER -eq 1 ];do
		unset OPTIONS SELECTION HOSTFILE SHOSTFILE
		# detect available host files
		while [ -z "$SHOSTFILE" ];do
			OPTIONS=($(for i in $(find -L $AINVENTORY/$TARGETENV -maxdepth 1 -type f -name "hosts*" |grep -v template);do echo ${i##*/} file;done))
			SHOSTFILE=$(F_DIALOG --menu "Select a hosts file:" 22 76 16 "${OPTIONS[@]}" manually "type in a path" 2>&1 >/dev/tty)
			[ $? -ne 0 ] && HOSTFILE="ABORTED" && F_ABORTMAINMENU 
		done
		if [ "$SHOSTFILE" == "manually" ];then
			SHOSTFILE=$(F_DIALOG --inputbox 'Type in your hosts filename' 20 100 $DEFHOSTFILE 2>&1 >/dev/tty)
		fi
		# construct the full host filename
		HOSTFILE="${AINVENTORY}/${TARGETENV}/${SHOSTFILE}"
		if [ ! -r "$HOSTFILE" ];then
			F_DIALOG --msgbox "\n\nERROR: $HOSTFILE does not exist or is not readable" 10 80
			STARTOVER=1
		else
			STARTOVER=0
		fi
	  done
    fi
    if [ ! -r "$HOSTFILE" ];then
	   [ "$RUNMODE" != "batch" ] && F_DIALOG --msgbox "\n\nERROR: $HOSTFILE does not exist or is not readable" 10 80 && return 3
       [ "$RUNMODE" == "batch" ] && echo "ERROR: $HOSTFILE does not exist or is not readable" && F_EXIT
	else
	    echo "HOSTFILE=\"$HOSTFILE\"" > $AEUSRHOSTFILE
	    F_LOG $FUNCNAME "written new AEUSRHOSTFILE ($AEUSRHOSTFILE):\n$(cat $AEUSRHOSTFILE)"
    fi
	F_LOG $FUNCNAME finished
}

## @fn F_TARGETS()
## @brief identify targets/hosts of a group
## @param 1 required: dialog option (checklist/radiolist)
## @param 2 optional: automatic/non interactive mode (auto selected group name|empty)
## @return list of hosts
## @exception on error or abort: abort
## @details identify targets/hosts of a group 
## 1. filter out all vars
## 2. get all sections and 1 next line
## 3. replace [ with newline
## 4. replace ] with comma, empty lines with / and remove children tag from group name
## 5. remove all newlines
## 6. replace // with /
## 7. replace / with newline
## --> steps 4-7 are required to ensure even when 2 sections are written without a space
##     between. Example:
##     [sec1]
##     [sec2]
##     host
##     As we catch always section + 1 next line on step 2 to identify empty sections the above 
##     steps ensure we will *NOT* have a result of: "sec1" has host "sec2"
## 8. get only these lines containing a comma and something behind (means section has a value)
##    this is needed as a section can be empty which shouldnt be shown if!
F_TARGETS(){
	F_LOG "$FUNCNAME" "started with these arguments: $@"
	
	#OPTIONS=($(for i in $(egrep -v "(:vars|:children)" "$HOSTFILE" | egrep --group-separator="/" -A1 "^\[.*\]"| tr "[" "\n" |sed -e 's/\]$/,/g;s/^$/\//g'| tr -d "\n" | sed 's#//#/#g' | tr "/" "\n" | egrep ",\w+" | cut -d "," -f1);do echo $i $i off; done | sort))
	OPTIONS=($(for i in $(egrep -v "(:vars)" "$HOSTFILE" | egrep --group-separator="/" -A1 "^\[.*\]"| tr "[" "\n" |sed -e 's/\]$/,/g;s/^$/\//g;s/:children//g'| tr -d "\n" | sed 's#//#/#g' | tr "/" "\n" | egrep ",\w+" | cut -d "," -f1);do echo $i $i off; done | sort -u ))
	# OPTIONS EXPLANATION ABOVE

	if [ -z "$1" ];then 
		echo -e "\n\nERROR! Missing F_TARGETS arg!! Cannot continue...\n" && F_EXIT
	else
		DOPT="$1"
	fi
	unset NIGRP
	NIGRP="$2"
	if [ -z "$NIGRP" ];then
	    HOSTSELECTION=$(F_DIALOG --${DOPT} "Please use the space-bar to make your selection:" 30 80 30 "${OPTIONS[@]}" 2>&1 >/dev/tty)
		HERR=$?
		F_LOG "$FUNCNAME" "HERR was $HERR"
		if [ "$HERR" != "0" ];then
			echo "ABORTED"
		else
			echo "$HOSTSELECTION"
		fi
	else
		#echo "${OPTIONS[@]} | cut -d ' ' -f 1 |grep $NIGRP"
		echo "$NIGRP"
	fi
	F_LOG "$FUNCNAME" "finished"
}

# group_vars dir check and initiate if needed
F_GVARDIR(){
	echo "$FUNCNAME started" >> $LOG
	INIT=0
	TG=$1
	TDIR=$AINVENTORY/$TARGETENV/group_vars/$TG
	[ -z "$TG" ]&& echo "Missing arg for $FUNCNAME!! ABORTED" && F_EXIT
	if [ -d "$TDIR" ];then
		echo "$TDIR" exists >> $LOG
		if [ -f "$TDIR/deployment" ];then 
			echo already initialized >> $LOG
		else
			INIT=1
		fi
	else
		INIT=1
	fi
	if [ "$INIT" -eq 1 ];then
		echo creating $TDIR >>$LOG
		mkdir $TDIR >>/dev/null 2>&1
		ERRC=0
		while [ -z "$DEPL" ]&&[ "$ERRC" -eq 0 ];do
			DEPL=$(F_DIALOG --inputbox "Initializing of <$TDIR> required\nPlease type in where you want to deploy apps for >$TG<.\n\nJust type <apps>, <deployment-apps>,<shcluster/apps>, etc and not the full path:" 15 100 2>&1 >/dev/tty)
			ERRC=$?
		done
		if [ $ERRC -eq 0 ];then
			echo "will create deployment file with: $DEPL as target dir" >> $LOG
			# creating deployment file:
			cat >> $TDIR/deployment <<EOF_DEPL
---
#####################################################################################################################
# Configurations for Splunk deployment directory
# Keep in mind to replace "-" and "/" with an underscore "_"
#####################################################################################################################

deployment:
    dir: $DEPL
EOF_DEPL
		fi
	fi
	echo "$FUNCNAME finished" >> $LOG
}

# deploy system/local configs
F_DEPLSYSC(){
	echo "$FUNCNAME started" >> $LOG
	F_HOSTFILE
	SELECTION="$1"
	if [ "$SELECTION" == "Choose" ];then
	     unset HOSTSELECT HOSTSELECTION
	     while [ -z "$HOSTSELECT" ];do
		HOSTSELECTION=$(F_TARGETS checklist)
		[ $HOSTSELECTION == "ABORTED" ] && ABORTED=1 && break
	         if [ -z "$HOSTSELECTION" ];then
                     F_DIALOG --msgbox "ERROR: no selection made. Choose 1 or more targets with space bar." 10 30 
                 else
                     HOSTSELECT=1
		     ABORTED=0
                 fi
	     done
	     if [ "$ABORTED" -ne 0 ];then
                echo "DEBUG: aborted by user."
	     else
		  F_DIALOG --yesno "\nAre you sure you want to continue?\n\nThis will deploy the system/local configs to:\n\n$HOSTSELECTION" 15 80
		  if [ $? -eq 1 ];then
			ABORTED=1 
		  else
		     # TODO: optimize playbook exec to just exec on group instead of for each host
			unset HOSTSELEXPANDED
			HOSTSELEXPANDED=$(F_EXPANDHOSTS "$HOSTSELECTION" | grep -v EMPTY |cut -d : -f 1)
			# host 1,2,3,... of shcmember
			for hex in $HOSTSELEXPANDED;do
			     F_LOG $FUNCNAME "processing host >$hex<"
			     for hgroup in $HOSTSELECTION;do
				    F_LOG $FUNCNAME "processing $hex in >$hgroup<"
				    # for shcmember, ...
			    	#F_GVARDIR "$hgroup"

				    # update task etc stuff first
                    F_LOG $FUNCNAME "roledir: $ROLEDIR"
				    F_TPLUPDATE "${ROLEDIR}/system" "$hgroup/$hex"

				    F_LOG $FUNCNAME "Will play:\n$ABIN -i $HOSTFILE $PBDEPLSYSC -e \"target=$hgroup exp_host=$hex\""
				    $ABIN -i $HOSTFILE $PBDEPLSYSC -e "target=$hgroup exp_host=$hex"
				    ERR=$?
				    F_DIAERR "$ERR" "on \Zb\Z1<$hex>\Zn"
				    [ $ERR -ne 0 ]&& F_MSG "ERROR: ABORTED deployment!" && break 2 >>$LOG
			     done
		     done
		  fi
	     fi
	else
		F_DIALOG --msgbox "ERROR: Deploying to ALL is not supported yet" 10 100
	fi
	echo "$FUNCNAME finished" >> $LOG
}

# let the user choose to either catch existing conf from another host or locally
F_SSHORNOT(){
	echo "$FUNCNAME started" >> $LOG
	unset ANS
	while [ -z "$ANS" ];do
		#ANS=$(F_DIALOG --radiolist "\nDo you want to active pull the current config or use a local copy instead?\n(use the space-bar to select)" 15 80 3 Pull "Pull existing conf from a host (copy by SCP)" on Local "Choose a local dir for importing conf" off Skip "Use the local copy (POTENTIAL DANGEROUS. Will overwrite remote changes if any)" off 2>&1 >/dev/tty)
		ANS=$(F_DIALOG --radiolist "\nDo you want to active pull the current config or use a local copy instead?\n(use the space-bar to select)" 15 100 5 Pull "(RECOMMENDED) Pull current active conf" on ---- "--------------------------------------" off DANGEROUS-Import "OVERWRITES REMOTE! Import configs from a LOCAL directory" off DANGEROUS-Skip "OVERWRITES REMOTE! Just use the LOCAL(!!) existing files" off 2>&1 >/dev/tty)
		ERR=$?
		echo "$FUNCNAME: err was $ERR" >> $LOG
		if [ $ERR -ne 0 ];then
			echo "$FUNCNAME: err was $ERR" >> $LOG
			ANS="ABORTED"
		fi
		# reset ans when the user has selected the hint text...
		[ "$ANS" == "----" ]&&unset ANS
	done
	echo "$FUNCNAME finished" >> $LOG
	echo $ANS
}

# import by ssh from an existing host
F_DIMPORT(){
	echo "$FUNCNAME started" >> $LOG
	SSHHOST="$1"
	SSHPATH="$2"
	LOCTMP="$3"
	[ -d $LOCTMP ]&& rm -R $LOCTMP
	mkdir $LOCTMP
	scp ${SSHHOST}:${SSHPATH}/*.conf $LOCTMP/

	# return errorcode to calling function
	echo $?

#	SIMP=$(F_DIALOG --inputbox "$TPLMSG\nNow initialize the deployment directory by copying your initial config files you want to deploy.\n\n\nWhere should I copy the initial configs from:" 15 80 2>&1 >/dev/tty)
	echo "$FUNCNAME finished" >> $LOG
}

# file browser
F_DBROWSE(){
	echo "$FUNCNAME started" >> $LOG
	unset SDIR
        SDIR=$(F_DIALOG --colors --inputbox "\nSource path (full path) where to copy the initial configs from\n(on host \Zb\Z1<$1>\Zn):" 15 80 $2 2>&1 >/dev/tty)
	if [ $? -ne 0 ];then
            SDIR=999
        fi
	echo $SDIR
	echo "$FUNCNAME finished" >> $LOG
}
## @fn F_LOCSRC()
## @brief List and choose local repository files 
## @param 1 (required) Target group
## @return choosen local hosted files
F_LOCSRC(){
	F_LOG $FUNCNAME "started with $@"
	unset SDIR OPTIONS
    TG="$1"
	[ ! -d "$REPODIR" ]&& echo "Cannot determine repo dir <$REPODIR>!! ABORTED" && F_EXIT

    # ensure only apps that are not already linked will be shown
    LINKEDAPPS=$(F_LISTAPPS "$TG" | grep ansible-hosted| cut -d ":" -f 2-3)
    AVAILAPPSFP=$(for tgzf in $(find $REPODIR -type f |egrep "(tar|tgz|spl)");do echo "$tgzf";done)
    AVAILAPPNAMES=$(for tgz in $AVAILAPPSFP;do APPN=$(tar tf "$tgz" 2> /dev/null |head -n1 | cut -d '/' -f1) ; echo "${APPN}:${tgz##*/}" ;done)
    UNLINKEDAPPS=$(echo "$LINKEDAPPS" "$AVAILAPPNAMES" | tr " " "\n" | sort | uniq -u)

    F_LOG $FUNCNAME "linked: $LINKEDAPPS\n\navail: ${AVAILAPPNAMES}\n\nunlinked: $UNLINKEDAPPS"

	OPTIONS=($(for tgz in $UNLINKEDAPPS;do echo "${tgz/*:}" "${tgz/:*}" off; done | sort))
	SDIR=$(F_DIALOG --checklist "Please use the space-bar to make your selection:" 40 100 40 "${OPTIONS[@]}" 2>&1 >/dev/tty)
        if [ $? -ne 0 ];then
            SDIR=999
        fi
        echo "$SDIR"
	F_LOG $FUNCNAME ended
}

## @fn F_EXPANDHOSTS()
## @brief create an expanded list of hostnames
## @param 1 target group name
## @return  space delimited list with the expanded list of hostnames
## @details expands a target group to a list of hostnames/ips defined in the users host file
F_EXPANDHOSTS(){
	F_LOG "$FUNCNAME" "started with these arguments: $@"
	unset RET
	TGROUP=$1
	source "$AEUSRHOSTFILE"
	if [ -f "$HOSTFILE" ];then
		TGFILE="$AINVENTORY/$TARGETENV/${FUNCNAME}_${TGROUP}"

		# get all hosts via playbook (will expand groups in groups etc)
                [ ! -s $VAULTTEMPFILE ] && [ "$ENABLEVAULT" == "yes" ] && F_VAULTPW
		$ABIN -i $HOSTFILE $PBGETTARGETS -e "target=$TGROUP expandfile=$TGFILE" 2>&1 | sort >> $LOG
                F_RMVAULTPW
	
		# parse the resulted FILE and massage its content
	        if [ -r "$TGFILE" ];then
       	       # filter ansible stuff:
		      RET=$(sed "s/,//g;s/\[//g;s/]//g;s/'//g" $TGFILE)
        	else
	      	# bark no error to the calling function but an error message in log
              	F_LOG $FUNCNAME "WARNING: cant read/find $TGFILE! Empty group??"
	      	RET="EMPTY"
        	fi
	else
		F_LOG $FUNCNAME "ERROR: HOSTFILE $HOSTFILE NOT FOUND!"
	fi
	echo "$RET"
	F_LOG "$FUNCNAME" finished
}

# validate a dir if it contains conf files
F_VALCONF(){
	echo "$FUNCNAME started" >> $LOG
	find $1 -type f |grep -q "\.conf"
	if [ $? -ne 0 ];then
		F_DIALOG --msgbox "ERROR:\n\nThe path >$1< contains no single conf file!" 10 50
	fi
	echo "$FUNCNAME finished" >> $LOG
}

# delete empty conf files
F_CLEANCONF(){
	echo "$FUNCNAME started" >> $LOG
	CDIR=$1
	for cfile in $(find $CDIR -type f -name *.conf);do
		[ ! -s "$cfile" ]&& echo "$cfile is empty! Will remove it" >> $LOG && rm -v "$cfile" >> $LOG
	done
	echo "$FUNCNAME finished" >> $LOG
}

# dialog box providing errorcde
F_DIAERR(){
	echo "$FUNCNAME started with args: $@" >> $LOG
	ERRC="$1"
	TASK="$2"

	[ -z "$ERRC" ]&&echo ERRORCODE MISSING for $FUNCNAME && F_EXIT

	if [ "$ERRC" != "0" ];then
		F_DIALOG --colors --msgbox "ERROR:\n\nTask\n\n$TASK\n\nended with errorcode >$ERRC<!" 50 150
		# TODO: option to abort completely?
	else
		F_DIALOG --colors --msgbox "SUCCESS:\n\nTask\n\n$TASK\n\nended successfully" 20 100
	fi
	echo "$FUNCNAME finished" >> $LOG
}

# dialog box very similar to F_DIAERR but givin an option to display a given logfile
F_ERRLOG(){
        echo "$FUNCNAME started" >> $LOG
        ERRC="$1"
        TASK="$2"
	DLOG="$3"

        [ -z "$ERRC" ]&&echo ERRORCODE MISSING for $FUNCNAME && F_EXIT

        if [ "$ERRC" != "0" ];then
                F_DIALOG --colors --extra-button --extra-label "Inspect" --msgbox "ERROR:\n\nTask:\n\n${TASK}\n\nended with errorcode >$ERRC<!" 20 150
                # TODO: option to abort completely?
		exit_status=$?
        else
                F_DIALOG --colors --extra-button --extra-label "Inspect" --msgbox "SUCCESS:\n\nTask:\n\n${TASK}\n\nended successfully" 20 150
		exit_status=$?
        fi
	if [ $exit_status -eq 3 ]; then
		F_DIALOG --colors --textbox "$DLOG" 50 200
	fi
        echo "$FUNCNAME finished" >> $LOG

}

# display a wait box
F_WAITBOX(){
	# requires 1 arg (message to show)
	MSG="$1"
	F_DIALOG --begin 3 3 --infobox "\n$MSG" 5 80
}

## @fn F_SETREPODIR()
## @brief Set the local repository variable in ae
## @return The directory name where the local repository is defined. On error it will return nothing.
## @details Set the local repository variable in ae
F_SETREPODIR(){  
    F_LOG $FUNCNAME started
    # local repository definition configuration file for tgz's  
    REPODEF=$AINVENTORY/$TARGETENV/group_vars/all/splunk_repository

    # extract repo dir for apps
    REPODIR="$(grep repository_root $REPODEF|cut -d ":" -f 2|tr -d " ")"

    # return only the repo dir when its a valid directory
    if [ -d "$REPODIR" ];then
        echo "$REPODIR"
    fi
    F_LOG $FUNCNAME "repo dir: $REPODIR"
    F_LOG $FUNCNAME ended
}

# enable an app for a host/target
F_ENAPP(){
	echo "$FUNCNAME started" >> $LOG
	unset HOSTFILE
	F_HOSTFILE
	unset HOSTSELEXPANDED ABORTED HTARGETS HOSTSELECT OPTIONS

	# local repository definition configuration file for tgz's	
	#REPODEF=$AINVENTORY/$TARGETENV/group_vars/all/splunk_repository

	# extract repo dir for apps
	#REPODIR="$(grep repository_root $REPODEF|cut -d ":" -f 2|tr -d " ")/apps"

    REPODIR="$(F_SETREPODIR)/apps"

        while [ -z "$HOSTSELECT" ];do
                HOSTSELECTION=$(F_TARGETS radiolist)
		[ $HOSTSELECTION == "ABORTED" ] && ABORTED=1 && break
                 if [ -z "$HOSTSELECTION" ];then
                     F_DIALOG --msgbox "ERROR: no selection made. Choose 1 or more targets with space bar." 10 30
                 else
                     HOSTSELECT=1
                     ABORTED=0
                 fi
        done
        if [ "$ABORTED" -ne 0 ];then
                echo "DEBUG: aborted by user."
        else
		#HOSTSELEXPANDED="$(F_EXPANDHOSTS "$HOSTSELECTION")"
		#F_SHOWHOSTS "checklist" "$HOSTSELEXPANDED"

		# LOCAL or GIT
		ENSRC=$(F_DIALOG --menu "\nChoose an option:" \
                        15 76 14 \
                        gitlab "(define an available app within your gitlab server)" \
                        local "(define and push a local file on this server to a target)" \
                        3>&1 1>&2 2>&3)
		
		case $ENSRC in
			local)
			unset SELAPPS
			# TODO: select apps then choose hosts
			SELAPPS=$(F_LOCSRC "$HOSTSELECTION")
		    if [ -z "$SELAPPS" ];then
                F_DIALOG --msgbox "\n\nAll local available apps are linked to $HOSTSELECTION already ..." 15 76
            else
			    # atm we have to use group otherwise we have to switch group_vars to targetgroup/host/ as well	
                	#SELHOSTS=$(F_SHOWHOSTS "checklist" "$HOSTSELEXPANDED")
	               	#HOSTSELEXPANDED="$(F_EXPANDHOSTS "$HOSTSELECTION")"
			    # enable app for each target group
			    for tapp in $SELAPPS;do
				    F_WAITBOX "... linking $tapp ..."
				    app_fulldir=$(find $REPODIR -type f -name $tapp |egrep "(tar|tgz|spl)")
				    app_dir=${app_fulldir%/*}
				    app_type=$(echo "$app_dir" | egrep -o '(/other$|/splunk$)')
				    F_LOG $FUNCNAME "app_fulldir: $app_fulldir, app_dir: $app_dir, app_type: $app_type"
				    if [ "$app_type" == "/other" -o "$app_type" == "/splunk" ];then
				        app_name=$(tar tf "$app_fulldir" 2> /dev/null |head -n1 | cut -d '/' -f1)
				    else
				        app_name=${app_dir##*/}
				        app_type="/${app_name}"
				    fi
				    for tgroup in $HOSTSELECTION;do
					    F_GVARDIR $tgroup
					    echo -e "will start playbook:\n$ABIN -i $HOSTFILE $PBENAPP -e \"app_name=$app_name app2group=$tgroup filename=$tapp git_url='' git_branch=''\":\n" >>$LOG
					    $ABIN -i $HOSTFILE $PBENAPP -e "app_type=$app_type app_name=$app_name app2group=$tgroup filename=$tapp git_url='' git_branch=''" >> $LOG 2>&1
					    [ $? -ne 0 ] && F_ERRLOG "1" "linking $app_name to $tgroup\n\n" "$LOG"
				    done
			    done
			    F_ERRLOG 0 "Linking apps finished" "$LOG"
            fi
			;;
			gitlab)
			unset SELAPPS
			# check if settings are done already:
			if [ -f $GLABSETTINGS ];then
				. $GLABSETTINGS
			else
				F_SETUP_GITLAB
			fi
			# get gitlab projects
			F_DIALOG --begin 3 3 --infobox "\nPlease standby until all gitlab projects have been parsed..." 5 80
			CSELAPPS=$(F_GITLABSRC|sort)
            echo "$CSELAPPS" |grep "returncode:0" >> $LOG
            if [ $? -eq 0 ];then
                    PREAPPS="${CSELAPPS/returncode:0}"
			        unset OPTIONS
                    # ensure only apps that are not already linked will be shown
                    RMAPPS=$(F_LISTAPPS "$HOSTSELECTION" | grep git-hosted | cut -d ":" -f 2)
                    LAPPS=$(for papp in $PREAPPS;do echo "${papp##*/}" ;done)
                    SELAPPS=$(echo "$LAPPS" "$RMAPPS" | sort |uniq -u)

                    F_LOG $FUNCNAME "RMS: $RMAPPS\n\nPREAPPS: ${PREAPPS}\n\nSELAPPS: $SELAPPS"
        		    OPTIONS=($(echo "CUSTOM GIT-Project off" && for gapp in $SELAPPS;do echo ${gapp##*/} "GIT-Project" off; done))
		            GLABAPP=$(F_DIALOG --checklist "\nPlease use the space-bar to make your selection:" 80 80 70 "${OPTIONS[@]}" 2>&1 >/dev/tty)
                if [ $? -eq 0 ];then
                    for gapp in $GLABAPP;do
				        if [ "$gapp" == "CUSTOM" ];then
					        gapp=$(F_DIALOG --inputbox '\nHINT: the project MUST exists already on the gitlab server!\nType in the gitlab project name (only the name):\n' 15 100 2>&1 >>/dev/tty)
				        fi
				        F_GITLABSRC | grep $gapp >>/dev/null
				        if [ $? -ne 0 ];then
					        F_MSG "ERROR: > $gapp < does not exists on gitlab! Please create the repository first. This app will be SKIPPED."
				        else
	                                app_full=$(echo "$SELAPPS" |tr " " "\n" |egrep "/${gapp}$")
	       	                        app_dir=${app_full%/*}
	       	                        app_namespace=${app_dir##*/}
					                F_LOG $FUNCNAME "gapp: $gapp, app_full: $app_full, app_dir: $app_dir, appnamespace: $app_namespace" 
	       	                        for tgroup in $HOSTSELECTION;do
                                        F_GVARDIR $tgroup
						                # TODO: may have an option for choosing branch?!
	                                    echo -e "will start playbook:\n$ABIN -i $HOSTFILE $PBENAPP -e \"app_name=$gapp app2group=$tgroup filename='' git_url=git@${GLABHOST}:${app_namespace} git_branch=''\":\n" >>$LOG
						                F_A2BIN $HOSTFILE $PBENAPP "Enable App" "-e {'app_name':'$gapp','app2group':'$tgroup','filename':'','git_url':'git@${GLABHOST}:${app_namespace}','git_branch':'master'}"
                                        LASTERR=$?
                                        [ $LASTERR != 0 ] && F_ERRLOG "$LASTERR" "linking\n\n$gapp\n\nto $tgroup\n\n" "$LOG"
	                                done
				          fi
                       done
                       F_ERRLOG 0 "linking $GLABAPP to $tgroup\n\n" "$LOG"
                  else
                        F_DIAERR 4 "Aborted by user"
                  fi
              else
                       F_DIAERR 9 "$FUNCNAME: GITLAB API ERROR!! CHECK $LOG"
              fi
			;;
			*)
			echo NO SELECTION MADE..
			;;
		esac
	fi
	echo "$FUNCNAME finished" >> $LOG
}

# ask user and write settings to local file
F_SETUP_GITLAB(){
	echo "$FUNCNAME started" >> $LOG
	# ask for server
	# ask for personal token
	# write config if all is fine (only)
	unset GLABHOST PTOKEN ERRHOST ERRTOK
	F_DIALOG --msgbox "\n(Re-)Initializing gitlab authentication!\n" 10 80

	while [ -z "$GLABHOST" ];do
		GLABHOST=$(F_DIALOG --inputbox '\nType the FQDN/IP of your gitlab server here (no URL!):\n' 15 100 2>&1 >>/dev/tty)
		ERRHOST=$?
		[ "$ERRHOST" -ne 0 ]&& break
	done
	while [ -z "$PTOKEN" ]&&[ "$ERRHOST" -eq 0 ];do
		PTOKEN=$(F_DIALOG --inputbox '\nOpen your gitlab web GUI\n -> Open your profile settings\n -> Create a personal Access Token\n -> type that token here:\n' 25 100 2>&1 >>/dev/tty)
		ERRTOK=$?
		[ "$ERRTOK" -ne 0 ]&& break
	done
	# error out or write the config if not
	if [ "$ERRHOST" -ne 0 ]||[ "$ERRTOK" -ne 0 ];then
		F_DIAERR "host var: $ERRHOST,token var: $ERRTOK"
	else
		echo -e "GLABHOST=\"$GLABHOST\"\nPTOKEN=\"$PTOKEN\"" > $GLABSETTINGS
	fi
	echo "$FUNCNAME finished" >> $LOG
}


# get all available gitlab projects for the current user
# this does not work with other git servers (think of ssh git@git-server info for those supporting this)
F_GITLABSRC(){
	F_LOG $FUNCNAME started
	# check of required vars are set
	# build gitlab URL
	# curl with the private token 
	# parse the result with python and grep for the wanted project URLs
    # HINT: no dialogs allowed here!
	unset ERRC
	if [ ! -z "$PTOKEN" ]&&[ ! -z "$GLABHOST" ];then
		# TODO: check for curl as a req
		# TODO: check for python and python module json.tool as a req

		# I'm not that happy with this URL because it seems to be so unflexible for future changes (besides that parsing grep)
		# ... but: it works atm..
		# page=1 and per_page are required otherwise you will see the per page setting in the users settings only (default 20)
                # max=100 according to https://docs.gitlab.com/ce/api/README.html#pagination
                GLABURL="https://$GLABHOST/api/v4/projects?simple=true&per_page=100"

                curl -k -s --header "PRIVATE-TOKEN: $PTOKEN" "${GLABURL}" --head | egrep "HTTP/.* 200 OK" >> $LOG
                if [ $? -eq 0 ];then
                    # fetch the needed page count first, then iterate over all pages
                    PAGECNT=$(curl -k -s --header "PRIVATE-TOKEN: $PTOKEN" "${GLABURL}" --head | grep 'X-Total-Pages' |egrep -o '[[:digit:]]' |tr -d '\n')
                    # debugging
                    # echo "curl -k -s --header \"PRIVATE-TOKEN: $PTOKEN\" \"${GLABURL}\" --head" >> $LOG
                    PAGE=1
                    F_LOG $FUNCNAME "page count on GLABURL is: $PAGECNT starting at page: $PAGE"

                    while [ "$PAGE" -le "$PAGECNT" ];do
                        F_LOG $FUNCNAME "parsing page $PAGE ..."
                        #curl -k -s --header "PRIVATE-TOKEN: $PTOKEN" "${GLABURL}&page=$PAGE" 2>&1 | python -mjson.tool >> $LOG
                        curl -k -s --header "PRIVATE-TOKEN: $PTOKEN" "${GLABURL}&page=$PAGE" | python -mjson.tool | sed 's/[\",]//g' | egrep "web_url:" |sed 's/\s*web_url:\s*//g'
                        PAGE=$((PAGE + 1))
                    done
                    ERRC=$?
                else
                    curl -k -s --header "PRIVATE-TOKEN: $PTOKEN" "${GLABURL}" --head >> $LOG
                    F_LOG $FUNCNAME "API ERROR! Check your gitlab config!\nconnecting to $GLABURL returned an error:\n$( curl -k -s --header \"PRIVATE-TOKEN: $PTOKEN\" \"${GLABURL}\" --head)\n\nstart AE with --advanced to re-initialize gitlab, check the access token in gitlab and ensure the gitlab API url is still correct"
                    ERRC=9
                fi
	fi
	echo "$FUNCNAME finished" >> $LOG
        echo "returncode:$ERRC"
}

# Just showing a simple message box with some dynamic info
F_MSG(){
	echo "$FUNCNAME started" >> $LOG
	# required arg: message
	MSG="$1"
	[ -z "$MSG" ]&& echo "FATAL: missing req arg in $FUNCNAME! ABORTED!" && F_EXIT
	F_DIALOG --msgbox "$MSG" 10 100
	echo "$FUNCNAME finished" >> $LOG
}

# updating target dirs based on the template dir
# this ensures consistent tasks for all config folders
F_TPLUPDATE(){
	echo "$FUNCNAME started" >> $LOG
	# required argument: targetgroup/hostname
	unset ROLEPATH
	
	FRPATH="$1"
	ROLEPATH="$2"

	if [ -z "$ROLEPATH" ]||[ ! -d "$FRPATH" ];then
		echo "FATAL: missing req arg in $FUNCNAME! $ROLEPATH and $FRPATH. ABORTED!" && F_EXIT
	fi

	if [ -d $FRPATH/$ROLEPATH ];then
		for i in $ROLEPATH;do
			cp -av $FRPATH/template/* $FRPATH/$i/ >>$LOG
			[ $? -ne 0 ]&&echo "FATAL: Cannot copy template to $FRPATH/$i/ !" && F_EXIT
		done
	else
		F_MSG "\nERROR: cannot find specified path: $ROLEPATH!"
	fi
	echo "$FUNCNAME finished" >> $LOG
}

# updating target dirs based on the APP template dir
# this ensures consistent tasks for all config folders
F_APPTPLUPDATE(){
        echo "$FUNCNAME started" >> $LOG
        # required argument: targetgroup/hostname
        unset ROLEPATH FRPATH

        FRPATH="$1" # roles/apps/app.template
        ROLEPATH="$2" # roles/apps/TA-xxxxxxxxxxxxxxxxxx-dsl

        #FRPATH="roles/system"

        if [ -z "$ROLEPATH" ]||[ ! -d "$FRPATH" ];then
                echo "FATAL: missing req arg in $FUNCNAME! $ROLEPATH and $FRPATH. ABORTED!" && F_EXIT
        fi

        cp -av $FRPATH/* $ROLEPATH/ >>$LOG
        [ $? -ne 0 ] && echo "FATAL: Cannot copy template to $ROLEPATH/ !" && F_EXIT
        echo "$FUNCNAME finished" >> $LOG
}

# pull system/local configs for remote server
F_PULLSYSC(){
	echo "$FUNCNAME started" >> $LOG
	ABORTED=0
	AUTO="$1"
	if [ -z "$AUTO" ];then
		[ -z "$HOSTFILE" ]&& F_HOSTFILE
		unset HOSTSELEXPANDED ABORTED SYScDIR HOSTSELECT HOSTSELECTION
       		while [ -z "$HOSTSELECT" ];do
			HOSTSELECTION=$(F_TARGETS radiolist)
			[ $HOSTSELECTION == "ABORTED" ] && ABORTED=1 && break
       	        	if [ -z "$HOSTSELECTION" ];then
       	              		F_DIALOG --msgbox "ERROR: no selection made. Choose 1 or more targets with space bar." 10 30
       	          	else
       	              		HOSTSELECT=1
			     	ABORTED=0
       	          	fi
        	done
	fi

	if [ "$ABORTED" -ne 0 ];then
		echo "$FUNCNAME: aborted by user." >>$LOG
		echo ABORTED
	else
		if [ -z "$AUTO" ];then
			HOSTSELEXPANDED=$(F_EXPANDHOSTS "$HOSTSELECTION")
			[ "$HOSTSELEXPANDED" == "ERROR" ]&& echo "FATAL: problem with expanding hosts for $HOSTSELECTION" && F_EXIT
			[ "$HOSTSELEXPANDED" == "EMPTY" ]&& F_LOG $FUNCNAME "Warning $HOSTSELECTION is empty?!"
		else
			HOSTSELEXPANDED="$AUTO"
		fi

		# set temporarly to always pull.
		# TODO: decide to make this configurable as a general user defined setting
		#ANS=$(F_SSHORNOT)
		ANS=Pull

		case "$ANS" in
			ABORTED)
			# return abort state
			echo ABORTED
			break
			;;
			DANGEROUS-Skip)
			echo SKIPPED
			;;
			DANGEROUS-Import|Pull)
	  		    for host in $(echo "$HOSTSELEXPANDED"| cut -d : -f1);do
				OWNDIR=$HOSTSELECTION/$host
				SYScDIR=${ROLEDIR}/system/$OWNDIR
				if [ ! -d "$SYScDIR/files" ];then
				    mkdir -p "$SYScDIR"
		    		TPLMSG="Base directory structure created!"
				else
                    rm -vf"$SYScDIR" && mkdir -p "$SYScDIR"
				    TPLMSG="Target dir exists already. CLEANED!"
				fi
	
				# this initiates the template files but also ensures that we keep all tasks and stuff current!
				F_TPLUPDATE "${ROLEDIR}/system" $OWNDIR
	
				# do stuff based on user selection
				if [ "$ANS" == "DANGEROUS-Import" ];then
				   SELDIR=$(F_DBROWSE "$host" /TYPE-IN-LOCAL-DIR)
				   [ "$SELDIR" == "999" ] && echo "breakout!" && break
				   while [ ! -d "$SELDIR" ]&&[ "$SELDIR" -ne 999 ];do
					F_DIALOG --msgbox "ERROR:\n\nThe path you entered is not a directory!" 10 50
					SELDIR=$(F_DBROWSE $host /TYPE-IN-LOCAL-DIR)
				   done
				   [ "$SELDIR" == "999" ] && break
				else
				    if [ ! -z "$REMDIR" ];then
					REMPATH="$REMDIR"
				    else
					REMPATH="/opt/splunk/etc/system/local"
				    fi
				    # disabled user conf temporarly
				    # TODO: put this into a general setting store instead?
				    #REMDIR=$(F_DBROWSE "$host" "$REMPATH")
				    REMDIR=$REMPATH

				    echo "$FUNCNAME remdir: $REMDIR" >> $LOG
				    if [ "$REMDIR" == "999" ];then
					echo "$FUNCNAME: aborted!" >> $LOG
					ABORTED=1
				    else
					    SELDIR="/tmp/$host"
					    SCPERR=$(F_DIMPORT $host "$REMDIR" "$SELDIR")
					    echo "$FUNCNAME: SCPERR was $SCPERR" >> $LOG
					    [ $SCPERR -ne 0 ]&& F_MSG "ERROR: Problem while importing from >$host<"
				    fi
				fi
				if [ "$ABORTED" != "1" ];then
					F_VALCONF "$SELDIR"
					F_CLEANCONF "$SELDIR"
					# again! because clean could had cleaned all..
					F_VALCONF "$SELDIR"
					cp -v $SELDIR/*.conf $SYScDIR/system_local_configs/files/system/local/ >> $LOG
					CPERR=$?
					echo "$FUNCNAME: CPERR was $CPERR" >> $LOG
					# ask if you want to manage all files or a subset only
					#F_ASKMANAGE "$SYScDIR"
				fi
			    done
			    if [ "$SELDIR" != "999" ]&&[ "$ABORTED" != "1" ];then
				echo "$FUNCNAME: not aborted" >> $LOG
				if [ $CPERR -eq 0 ]&&[ $SCPERR -eq 0 ] ;then
					echo "$FUNCNAME: all files copied fine" >> $LOG
					#F_DIALOG --msgbox "DONE:\n\nAll files copied successfully." 15 80
				else
					echo "$FUNCNAME: ERROR: A problem occurred while copying your source files" >> $LOG
					echo "ERROR"
					#F_DIALOG --msgbox "ERROR:\n\nA problem occurred while copying your source files!" 10 50
				fi
			    else
				echo "$FUNCNAME: ABORTED" >> $LOG
				echo "ABORTED"
			    fi
			;;
			*) # this should never happen
			echo "$FUNCNAME - ERROR: No valid arg for case ($ANS)" >> $LOG
			echo "$FUNCNAME:ERROR"
			F_EXIT
			;;
		esac
	fi
	echo "$FUNCNAME finished" >> $LOG
}

# show hostnames in an expanded target group
F_SHOWHOSTS(){
	F_LOG $FUNCNAME "started"
	unset OPTIONS HTARGETS HOSTSELEXPANDED host ABORTED DIAOPT
	DIAOPT="$1"
	HOSTSELEXPANDED="$2"
	[ -z "$DIAOPT" ]&& echo "ABORTED! Missing arg for dialog in $FUNCNAME!" && F_EXIT 1
	[ -z "$HOSTSELEXPANDED" ]&& echo "ABORTED! Missing arg for target group in $FUNCNAME!" && F_EXIT 2

	OPTIONS=($(for host in $HOSTSELEXPANDED;do echo "$host $host off";done))

        while [ -z "$HTARGETS" ];do
	      ABORTED=0
              HTARGETS=$(F_DIALOG --${DIAOPT} "\nThe following are members of the choosen target group(s)\n<$HOSTSELECTION>\n\nMake your selection:" 30 80 50 "${OPTIONS[@]}" 2>&1 >/dev/tty)
              [ $? -eq 1 ] && ABORTED=1 && break
	      F_LOG $FUNCNAME "HTARGETS (while): >$HTARGETS<"
        done
	F_LOG $FUNCNAME "HTARGETS (end): $HTARGETS"
	F_LOG $FUNCNAME "finished"
	# return host objects to the calling function
	[ "$ABORTED" -eq 0 ] && echo "$HTARGETS"
}

# show available enviroments to the user and let the user select one
F_CHOOSEENV(){
	# returns the choosen environment so call this function like:
	# ENVCHOICE="$(F_CHOOSEENV)"
	F_LOG $FUNCNAME "started"

        OPTIONS=($(for inv in $(find $AINVENTORY/* -maxdepth 0 -type d);do echo "${inv##*/} $inv off";done | sort -r))

        while [ -z "$ENVTARGET" ];do
              ABORTED=0
              ENVTARGET=$(F_DIALOG --radiolist "\nYou HAVE TO choose an environment first.\n\nThe following are the available environment(s) based on\n<$AINVENTORY>\n\nMake your selection:" 30 80 30 "${OPTIONS[@]}" 2>&1 >/dev/tty)
              [ $? -eq 1 ] && ABORTED=1 && break
              F_LOG $FUNCNAME "ENVTARGET (while): >$ENVTARGET<"
        done
        F_LOG $FUNCNAME "ENVTARGET (end): $ENVTARGET"
        F_LOG $FUNCNAME "finished"
        # return objects to the calling function
        [ "$ABORTED" -ne 0 ] && ENVTARGET="ABORTED"
	echo "$ENVTARGET"
}

# manage local conf files 
F_EDITSYSC(){
	echo "$FUNCNAME started" >> $LOG
        unset HOSTSELEXPANDED ABORTED SYScDIR HOSTSELECT EDITHOST host
	F_HOSTFILE
        while [ -z "$HOSTSELECT" ];do
                HOSTSELECTION=$(F_TARGETS radiolist)
		if [ "$HOSTSELECTION" == "ABORTED" ];then
			ABORTED=1 && break
		else
                 	if [ -z "$HOSTSELECTION" ];then
                     		F_DIALOG --msgbox "ERROR: no selection made. Choose a target with space bar." 10 30
                 	else
                     		HOSTSELECT=1
                     		ABORTED=0
                 	fi
		fi
        done
        if [ "$ABORTED" -eq 1 ];then
                echo "$FUNCNAME: aborted by user." >> $LOG
        else
		HABORTED=0
		while [ $HABORTED -ne 1 ];do
			#TODO: ask if the user want to edit/open a path or manage previously pulled conf files
			# e.g. to say for the shc group do not manage authorize.conf

			HOSTSELEXPANDED=$(F_EXPANDHOSTS "$HOSTSELECTION" |cut -d : -f1)
			EDITHOST="$(F_SHOWHOSTS radiolist "$HOSTSELEXPANDED")"
			[ $? -eq 1 ] && HABORTED=1 && break

			PERR=$(F_PULLSYSC $EDITHOST)
			[ "$PERR" == "ABORTED" -o "$PERR" == "ERROR" ] && HABORTED=1 && unset SELECTION &&break 
			
			echo "$FUNCNAME: Continuing after pull selection ($PERR)" >> $LOG

			SYSDIR=${ROLEDIR}/system/$HOSTSELECTION/$EDITHOST/system_local_configs/files/system/local
			unset OPTIONS
       			OPTIONS=($(for hostfile in $(find $SYSDIR -type f) ;do echo "${hostfile##*/}" "file";done|sort -f))
		        while [ -z "$FTARGET" ];do
				unset DIROPENED
        	      		FTARGET=$(F_DIALOG --colors --extra-button --ok-label "Open file" --extra-label "Open directory" --cancel-label "Finish" --menu "\nThe following are files currently active for the given host\n\n\Zb\Z1<$EDITHOST>\Zn\n\nChoose one file for editing:" 30 80 30 "${OPTIONS[@]}" 2>&1 >/dev/tty)
				FERR=$?
				if [ $FERR -eq 1 ];then
					ABORTED=1
					unset FTARGET && break
				else
					# if the user uses the extra button we open a dir on CLI
					if [ $FERR -eq 3 ];then
						DIROPENED=1
						unset FTARGET
						clear
						echo -e "\n\nSwitching to directory: $SYSDIR"
						echo -e "\n***********************************************************************"
						echo -e "** Go back by typing <exit> or <CTRL+D>"
						echo -e "***********************************************************************\n"
						bash --rcfile <(echo "PS1=\"$EDITHOST/system/local \$>\";cd $SYSDIR/ && ls -la")
					else
						if [ -z "$FTARGET" ];then
               	           		      F_DIALOG --msgbox "ERROR: no selection made. Choose a file." 10 30
			                                ABORTED=1
               				        else
               	             			#FTARGET=1
			                                ABORTED=0
               	 		        fi
					fi
				fi
				# open file for editing
				if [ "$ABORTED" -eq 0 ]&&[ -z "$DIROPENED" ]&&[ "$HABORTED" -ne 1 ];then
					if [ -f $SYSDIR/${FTARGET} ];then
						$EDITBIN $SYSDIR/${FTARGET}
					else
						F_DIALOG --msgbox "NO FILES THERE?! Directory seems to be empty try a pull first" 10 30
						break
					fi
					unset FTARGET
				fi	
        		done
		done
	fi
	echo "$FUNCNAME finished" >> $LOG
}

# abort current menu and go back to MAIN dialog
F_ABORTMAINMENU(){
	F_LOG "$FUNCNAME" "started with $MAINMENU , params: $@"
	$MAINMENU
	F_LOG "$FUNCNAME" ended
}

# shelper gui
F_SHELPER(){
	F_LOG "$FUNCNAME" started
 	while [ "$MENUDONE" == "0" ]; do
		SELECTION=$(F_DIALOG --ok-label "Select Entry" --cancel-label "Exit" \
			--menu "\nshelper the splunk helper tool.\n\nSelect an option:" \
			15 100 15 \
			"" "" \
			"Upgrade/Install" "Will install or upgrade shelper on given machines" \
			Exec "Will execute certain shelper commands on given machines" \
			"" "" \
			"" "" \
			3>&1 1>&2 2>&3)
		if [ "$?" != "0" ]; then
		    MENUDONE=1
		    echo "$0: finished."
		    return 4
		fi
		case "$SELECTION" in
			"Upgrade/Install")
			F_SHUPGRADE
			;;
			Exec)
			F_SHEXEC
			;;
		esac
	done
}

## @fn F_CALCTGROUP()
## @brief create a temporary target group with selected hosts
## @param 1 required: temporary filename
## @param 2 optional: temporary target group-name within the hosts file
## @param 3 optional: a given target group for just generating host names
## @exception when param1 missing
## @details calculate a temporary group based on user selected values
## the result is a list of hosts all added to one group which allows easy
## handling when running playbooks
F_CALCTGROUP(){
    F_LOG "$FUNCNAME" started
    unset HOSTSELEXPANDED ABORTED HOSTSELECT HOSTFILE tgroup
    TMPGRP=aetmpgrp

	[ -z $1 ] && F_LOG $FUNCNAME "ERROR: missing filename for temp hosts file" && F_EXIT

    if [ ! -z "$3" ];then
        TMPGRP="$2"
        HOSTSELECT=1
        HOSTSELECTION="$3"
    else
        [ ! -z "$2" ] && TMPGRP="$2"
    fi

	CALCGRPF=${AINVENTORY}/${TARGETENV}/$1

        F_HOSTFILE
        while [ -z "$HOSTSELECT" ];do
                HOSTSELECTION=$(F_TARGETS checklist)
                if [ "$HOSTSELECTION" == "ABORTED" ];then
                        ABORTED=1 && break
			[ $? -ne 0 ] && F_ABORTMAINMENU
                else
                        if [ -z "$HOSTSELECTION" ];then
                                F_DIALOG --msgbox "ERROR: no selection made. Choose a target with space bar." 10 30
                        else
                                HOSTSELECT=1
                                ABORTED=0
                        fi
                fi
        done
	[ $ABORTED -eq 1 ] && F_ABORTMAINMENU

	# ask for specific hosts or target group?
	unset HOSTLIST['expanded']
	F_DIALOG --begin 3 3 --infobox "\nPlease standby until all hostnames from your target groups are generated" 5 80
	for hostlist in $HOSTSELECTION;do
		if [ -z "${HOSTLIST['expanded']}" ];then
			HOSTLIST['expanded']+="$(F_EXPANDHOSTS $hostlist | grep -v EMPTY)"
		else
			HOSTLIST['expanded']+=" $(F_EXPANDHOSTS $hostlist | grep -v EMPTY)"
		fi
	done

	unset EDITHOST	
	while [ -z "$EDITHOST" ];do
	        EDITHOST=$(F_SHOWHOSTS checklist "${HOSTLIST['expanded']}")
		if [ -z "$EDITHOST" ];then
			F_DIALOG --yesno "No selection made! Retry?" 10 40
			[ $? -ne 0 ] && F_ABORTMAINMENU
		fi
	done

	# make host list unique to avoid duplicated upgrades when a host is in multiple groups
	# number each entry,sort by name and remove dups, sort by num
	CALCEDHOSTS=$(echo "$EDITHOST" | tr ' ' '\n' | nl| sort -u -k2|sort -n| cut -f2-|tr '\n' ' ')
	CALCEDHOSTST="$(echo "$CALCEDHOSTS" | sed 's/ /\\n/g')"
	UPGRADEHOSTS=$(echo "$EDITHOST" | tr ' ' '\n' | nl| sort -u -k2|sort -n| cut -f2-|tr '\n' ' ')
	UPGRADEHOSTST="$(echo "$UPGRADEHOSTS" | sed 's/ /\\n/g')"

	F_LOG "$FUNCNAME" "Will do action on: <$CALCEDHOSTS>"
	[ $? -ne 0 ] && F_ABORTMAINMENU

	# create a temporary ansible group (must be in the correct env path! otherwise varibles cant be found)
	echo '['$TMPGRP']' > $CALCGRPF
	for h in $CALCEDHOSTS;do echo "$h" >> $CALCGRPF; done
	F_LOG "$FUNCNAME" "Temporary group: $(cat $CALCGRPF)"
}

## @fn F_SPLACT()
## @brief splunk action/task/command
## @details will exec a (predefined) splunk action/task/command
## splunk_action=X (where X must be defined in common/handlers)
F_SPLACT(){ 
        F_LOG "$FUNCNAME" started
	unset SPLEXE

	while [ -z "$SPLEXE" ];do
		SPLEXE=$(F_DIALOG --radiolist "\nChoose your splunk action:\n \
		(use the space-bar to select)" 15 100 5 \
			stop "stop splunk>" off \
			start "start splunk>" off \
			restart "restart splunk>" off \
			2>&1 >/dev/tty)
		ERR=$?
		echo "$FUNCNAME: err was $ERR" >> $LOG
		if [ $ERR -ne 0 ];then
			F_LOG "$FUNCNAME" "ABORTED due to err $ERR"
			F_ABORTMAINMENU
		fi
	done

        while [ -z "$HOSTSELECT" ];do
            HOSTSELECTION=$(F_TARGETS checklist)
            if [ "$HOSTSELECTION" == "ABORTED" ];then
                ABORTED=1 && break
                [ $? -ne 0 ] && F_ABORTMAINMENU
            else
                if [ -z "$HOSTSELECTION" ];then
                    F_DIALOG --msgbox "ERROR: no selection made. Choose a target with space bar." 10 30
                else
                    HOSTSELECT=1
                    ABORTED=0
                fi
            fi
        done
        [ $ABORTED -eq 1 ] && F_ABORTMAINMENU

        OLDPP="$PYTHONPATH"
        F_LOG $FUNCNAME "python path before: $OLDPP"
        export PYTHONPATH=${A2PATH}/lib
        F_LOG $FUNCNAME "python path after: $PYTHONPATH"
	export PYTHONUNBUFFERED=1

        ACTGRP=aedosomething
        FINISHED=0

        while [ $FINISHED -ne 1 ];do
            # calc temp hosts file
            F_CALCTGROUP splacthosts $ACTGRP "$HOSTSELECTION"
            F_LOG $FUNCNAME "calctgrp ended with $?"

	    $A2BIN -i "${AINVENTORY}/${TARGETENV}/splacthosts" "$PBSPLACT" --limit $ACTGRP -e "{'splunk_user':'$SPLUSR','splunk_password':'$SPLPW','splunk_action':'$SPLEXE'}" 2>&1 \
		| tee -a $LOG \
		| sed -u -r 's/(.*DEPRECATION.*)//Ig' \
		| F_DIALOG --scrollbar --colors --progressbox "\\Za\\Z1running splunk $SPLEXE on $CALCEDHOSTS ...\\Z\\n" 1000 1000
            F_ERRLOG "${PIPESTATUS[0]}" "splunk $SPLEXE for:\n\n$CALCEDHOSTST" "$LOG"
        done

        export PYTHONPATH="$OLDPP"  
        F_LOG $FUNCNAME "previous python path restored: $PYTHONPATH"
	F_LOG "$FUNCNAME" ended
	F_MENUMAIN
}

## @fn F_SHEXEC()
## @brief splunkhelper actions
## @details execute splunk helper commands
F_SHEXEC(){ 
        F_LOG "$FUNCNAME" started
	unset ANS

	while [ -z "$ANS" ];do
		ANS=$(F_DIALOG --radiolist "\nChoose your shelper action:\n \
		(use the space-bar to select)" 15 100 5 \
			reload-all "shelperreload all - so a full debug refresh" on \
			DS-reload "reloads the serverclass on a DS (deploymentserver)" off \
			SHC-apply-cb "apply cluster-bundle on a DEP (deployer)" off \
			MN-apply-cb "apply cluster-bundle on a MN (masternode)" off \
			custom-reload "define your own reload command" off \
			2>&1 >/dev/tty)
		ERR=$?
		echo "$FUNCNAME: err was $ERR" >> $LOG
		if [ $ERR -ne 0 ];then
			echo "$FUNCNAME: err was $ERR" >> $LOG
			ANS="ABORTED"
		fi
		# reset ans when the user has selected the hint text...
		[ "$ANS" == "----" ]&&unset ANS
	done

    TMPGRP=aetmpgrp
    unset ADDIGRP

	case $ANS in 
		custom-reload)
			unset SHCUST
			while [ -z "$SHCUST" ];do
                	  SHCUST=$(F_DIALOG --inputbox '\n\nType your custom reload arguments (space separated).\ne.g. "apps panels transforms searches"' 20 100 "" 2>&1 >/dev/tty)
                	  [ $? -ne 0 ] && F_ABORTMAINMENU
        		done
			SHEXE="reload custom"
			#SHCUST=$(echo $SHCUSTRAW | sed 's/ /SPACE/g')
		;;
		reload-all) SHEXE="reload all" ;;
        DS-reload) SHEXE="reload deploy-server" ;TMPGRP=deploymentserver ;;
        MN-apply-cb) SHEXE="apply cluster-bundle" ; TMPGRP=masternode ;;
        SHC-apply-cb) SHEXE="apply shcluster-bundle"; TMPGRP=deployer ; SCNDGRP=shcmember ;;
		*)	# TODO: do not exit but go to MAIN
			F_LOG $FUNCNAME "no answer given! aborted!"
			F_EXIT
		;;
	esac

	# calc temp hosts file
	F_CALCTGROUP shelperhosts $TMPGRP

    # some targets require other groups as a dependency in the tmp host file we generated in F_CALCTGROUP
    if [ ! -z "$SCNDGRP" ];then
        HOSTSELECTION=$(F_TARGETS checklist $SCNDGRP)
        unset HOSTLIST['expanded']
        F_DIALOG --begin 3 3 --infobox "\nPlease standby until all group members are generated" 5 80
        for hostlist in $HOSTSELECTION;do
            if [ -z "${HOSTLIST['expanded']}" ];then
                HOSTLIST['expanded']+="$(F_EXPANDHOSTS $hostlist | grep -v EMPTY)"
            else
                HOSTLIST['expanded']+=" $(F_EXPANDHOSTS $hostlist | grep -v EMPTY)"
            fi
        done
        echo -e '\n['$SCNDGRP']' >> ${AINVENTORY}/${TARGETENV}/shelperhosts
        echo "${HOSTLIST['expanded']}" >> ${AINVENTORY}/${TARGETENV}/shelperhosts
    fi

    OLDPP="$PYTHONPATH"
    F_LOG $FUNCNAME "python path before: $OLDPP"
    export PYTHONPATH=${A2PATH}/lib
	export PYTHONUNBUFFERED=1
    F_LOG $FUNCNAME "python path after: $PYTHONPATH"

    #[ ! -z "$SPLPW" ] && SHEXE="$SHEXE with auth"
    F_LOG $FUNCNAME "will use >$SHEXE<"

	CREDS=$(F_GETAPICREDS)
	SPLUSR="${CREDS/:*}"
	SPLPW="${CREDS/*:}"

	$A2BIN -i "${AINVENTORY}/${TARGETENV}/shelperhosts" "$PBSHRELOAD" --limit $TMPGRP -e "{'splunk_user':'$SPLUSR','splunk_password':'$SPLPW','shelper_action':'$SHEXE','shelper_custom':'$SHCUST'}" 2>&1 \
		| tee -a $LOG \
		| sed -u -r 's/(.*DEPRECATION.*)//Ig' \
		| F_DIALOG --scrollbar --colors --progressbox "\\Za\\Z1shelper running with $SHEXE $SHCUST on $UPGRADEHOSTS ...\\Z\\n" 1000 1000
        F_ERRLOG "${PIPESTATUS[0]}" "$SHEXE $SHCUST for:\n\n$UPGRADEHOSTST" "$LOG"

    export PYTHONPATH="$OLDPP"  
    F_LOG $FUNCNAME "previous python path restored: $PYTHONPATH"
	F_MENUMAIN
}

# install/upgrade/use shelper
F_SHUPGRADE(){
        echo "$FUNCNAME started" >> $LOG
        unset HOSTSELEXPANDED ABORTED HOSTSELECT HOSTFILE tgroup
        F_HOSTFILE
        while [ -z "$HOSTSELECT" ];do
                HOSTSELECTION=$(F_TARGETS checklist)
                if [ "$HOSTSELECTION" == "ABORTED" ];then
                        ABORTED=1 && break
			[ $? -ne 0 ] && F_ABORTMAINMENU
                else
                        if [ -z "$HOSTSELECTION" ];then
                                F_DIALOG --msgbox "ERROR: no selection made. Choose a target with space bar." 10 30
                        else
                                HOSTSELECT=1
                                ABORTED=0
                        fi
                fi
        done
	[ $ABORTED -eq 1 ] && F_ABORTMAINMENU

	PLPW=""
	SPLPWR=fail

	# ask for specific hosts or target group?
	unset HOSTLIST['expanded']
	F_DIALOG --begin 3 3 --infobox "\nPlease standby until all hostnames from your target groups are generated" 5 80
	for hostlist in $HOSTSELECTION;do
		if [ -z "${HOSTLIST['expanded']}" ];then
			HOSTLIST['expanded']+="$(F_EXPANDHOSTS $hostlist | grep -v EMPTY)"
		else
			HOSTLIST['expanded']+=" $(F_EXPANDHOSTS $hostlist | grep -v EMPTY)"
		fi
	done

	unset EDITHOST	
	while [ -z "$EDITHOST" ];do
	        EDITHOST=$(F_SHOWHOSTS checklist "${HOSTLIST['expanded']}")
		if [ -z "$EDITHOST" ];then
			F_DIALOG --yesno "No selection made! Retry?" 10 40
			[ $? -ne 0 ] && F_ABORTMAINMENU
		fi
	done

	# make host list unique to avoid duplicated upgrades when a host is in multiple groups
	# number each entry,sort by name and remove dups, sort by num
	UPGRADEHOSTS=$(echo "$EDITHOST" | tr ' ' '\n' | nl| sort -u -k2|sort -n| cut -f2-|tr '\n' ' ')
	UPGRADEHOSTST="$(echo "$UPGRADEHOSTS" | sed 's/ /\\n/g')"

	F_LOG "$FUNCNAME" "Will upgrade/install shelper on: <$UPGRADEHOSTS>"
	F_DIALOG --scrollbar --yesno "Will upgrade/install shelper on these hosts:\n\n$UPGRADEHOSTST\n\nAre you sure?" 30 100
	[ $? -ne 0 ] && F_ABORTMAINMENU

	# create a temporary ansible group (must be in the correct env path! otherwise varibles cant be found)
	UTMPGRP=${AINVENTORY}/${TARGETENV}/shelperhosts
	echo '[tmpshmaint]' > $UTMPGRP
	for h in $UPGRADEHOSTS;do echo "$h" >> $UTMPGRP; done
	F_LOG "$FUNCNAME" "Temporary group: $(cat $UTMPGRP)"

 	F_LOG $FUNCNAME "F_A2BIN $UTMPGRP $PBSHINSTALL '--limit tmpshmaint" | tee -a $LOG

	# do it
	F_A2BIN "$UTMPGRP" "$PBSHINSTALL" "\Za\Z1UPGRADING/INSTALLING ...\Z\n" "--limit tmpshmaint" 
        F_ERRLOG "${PIPESTATUS[0]}" "shelper upgrade/install for:\n\n$UPGRADEHOSTST" "$LOG"
}

# ask for splunk_user and splunk_password vars
F_GETAPICREDS(){
	PLPW=""
	SPLPWR=fail

	while [ "$SPLPW" != "$SPLPWR" ];do
		[ -z "$PREUSR" ] && PREUSR=$DEFSPLAPIADMIN

		SPLUSR=$(F_DIALOG --inputbox '\n\nADMIN username for splunk API\n(only required for Indexer peer nodes - leave empty otherwise)' 20 100 $PREUSR 2>&1 >/dev/tty)
		[ $? -ne 0 ] && F_ABORTMAINMENU
		PREUSR=$SPLUSR
		SPLPW=$(F_DIALOG --passwordbox '\n\nADMIN password for splunk API\n(supports only these special chars for sure: -,_,%,@)\nYOU WILL SEE NOTHING WHILE TYPING!' 20 100 2>&1 >/dev/tty)
		[ $? -ne 0 ] && F_ABORTMAINMENU
		SPLPWR=$(F_DIALOG --passwordbox '\n\nTo verify the ADMIN password for splunk API write it again' 20 100 2>&1 >/dev/tty)
		[ $? -ne 0 ] && F_ABORTMAINMENU
		[ "$SPLPW" != "$SPLPWR" ] && F_DIAERR "3" "ERROR: Passwords doesn't match!"
	done

	[ -z "$SPLPW" ]&& F_LOG $FUNCNAME "No password set!"
	echo "$SPLUSR:$SPLPW"
}

## @fn F_LISTSPLREPO()
## @brief Lists splunk versions in the local repo
## @return a list of splunk packages (filenames) ordered by version top-level down
## @details Lists available splunk versions in the local repository
F_LISTSPLREPO() { 
    F_LOG $FUNCNAME started
    REPODIR="$(F_SETREPODIR)"
    find ${REPODIR}/packages -maxdepth 1 -type f -name splunk*rpm -or -name splunk*deb -or -name splunk*tgz | tac | sed 's#.*/##g'
    F_LOG $FUNCNAME ended
}

## @fn F_DLSPLUNK()
## @brief Downloads a specific splunk release
## @return success/error
## @details Takes an URL parses the relevant parts out of it and downloads splunk to the local repo
F_DLSPLUNK() { 
    F_LOG $FUNCNAME started
    while [ -z "$VERINFO" ];do
        VERINFO=$(F_DIALOG --colors --inputbox 'This will download splunk based on just the version number & the hash value.\nGuide to get version and hash:\n\n1) open https://www.splunk.com/page/previous_releases#x86_64linux\n   (select the URL and use your terminal copy-hotkey)\n2) find the wanted version but do not click on it\n3) identify the version and hash from the package name\n\nExample:\nsplunk-\Zb7.0.1-2b5b15c4ee89\ZB-Linux-x86_64.tgz\n\nResult: \n7.0.1 = version, 2b5b15c4ee89 = hash\n\nType or paste in the version & hash ONLY.\nThe format must be exactly like this: 7.0.1-2b5b15c4ee89 (X.x.x-hash):\n' 30 100 2>&1 >>/dev/tty || echo 1)
        F_LOG $FUNCNAME "input was: $VERINFO"
        [ "$VERINFO" == "1" ] && unset VERINFO && return 3
        
        echo "$VERINFO" | egrep -q "[0-9]*\.[0-9]*\.[0-9]*-\w*"
        if [ $? -eq 0 ];then
            NVER=$(echo "$VERINFO" | cut -d "-" -f 1 | tr -d " ")
            NHASH=$(echo "$VERINFO" | cut -d "-" -f 2 | tr -d " ")
            if [ -z "$NVER" ];then
                unset VERINFO && F_ERRLOG "3" "$FUNCNAME: Cannot parse the splunk version! Try again" "$LOG"
            else
                echo "$NVER" | egrep -q "^[[:digit:]]"
                [ $? -ne 0 ] && unset VERINFO && F_ERRLOG "3" "$FUNCNAME: Version does not start with a number! Try again" "$LOG"
            fi  
            [ -z "$NHASH" ] && unset VERINFO && F_ERRLOG "3" "$FUNCNAME: Cannot parse the splunk hash! Try again" "$LOG"
        else
            F_ERRLOG "3" "$FUNCNAME: You typed: $VERINFO which is not in the correct format!" "$LOG"
            unset VERINFO
        fi
    done
    # auto-stage the given version 
    F_STAGESPL "${NVER}:${NHASH}"
   
    F_LOG $FUNCNAME "Parsed version: $NVER, parsed hash: $NHASH"
    
    # download the auto-staged version
    [ ! -s $VAULTTEMPFILE ] && [ "$ENABLEVAULT" == "yes" ] && F_VAULTPW
    F_A2BIN $HOSTFILE $PBDLSPL "Downloading splunk <$NVER>..."
    F_RMVAULTPW
    ERR=$?
    F_DIAERR $ERR "Downloading splunk version: $NVER"
    [ $ERR -eq 0 ] && F_DIALOG --infobox "\nSplunk $NVER has been staged automatically." 5 80
    
    F_LOG $FUNCNAME ended
}

## @fn F_GETSTAGEDSPL()
## @brief Get the current staged splunk version
## @return version string of the current staged splunk package
## @details Parses the local global var to identify the current staged splunk version
F_GETSTAGEDSPL(){ 
    F_LOG $FUNCNAME started
    # extract repo dir for apps
    STAGEDVER="$(grep ^globversion "$AINVENTORY/$TARGETENV/group_vars/all/$INSTDEF" |cut -d ":" -f 2 | grep -Po '\d+\.\d+\.\d+')"
 
    if [ ! -z "$STAGEDVER" ];then
        echo "$STAGEDVER"
    fi
    F_LOG $FUNCNAME "current version string: $STAGEDVER"
    F_LOG $FUNCNAME ended
}

## @fn F_STAGESPL()
## @brief Stage a specific splunk version from the local repository
## @param 1 OPTIONAL: splunk version:hash -> will auto-stage the given version + hash
## @return success/error
## @details Parses the local repository for available splunk versions, let the user choose and stage that version for the ae upgrade function
F_STAGESPL(){ 
    F_LOG $FUNCNAME "started with $@"
    unset FVER VER VERHASH SELECTION AUTOVER
    AUTOVER="$1"
    STAGEDSPLVER=$(F_GETSTAGEDSPL)
    
    if [ -z "$AUTOVER" ];then
        # get the local avail versions
        OPTIONS=($(for i in $(F_LISTSPLREPO | grep -P -o "splunk-(\d+\.\d+\.\d+)-(\w+)");do VER=$(echo "${i}" | cut -d "-" -f 2); VHASH=$(echo "${i}"| cut -d "-" -f 3); echo "$VER" "$VHASH" off;done))

	    F_LOG $FUNCNAME "splunk packages found in local repo:\n$(F_LISTSPLREPO)"

        SELECTION=$(F_DIALOG --colors --ok-label "Stage" --radiolist "\nThe following shows your local repository for splunk Enterprise packages\n\nCurrently active/staged splunk version:\n\n \Zb\Zu${STAGEDSPLVER}\ZB\ZU\n\nTo stage another version simply select (space bar) and choose select.\n\n" \
                40 80 40 \
                "${OPTIONS[@]}" \
                2>&1 >/dev/tty)

        [ $? -ne 0 ] && F_LOG $FUNCNAME "aborted by user" && return 4

        FVER=$(echo "${OPTIONS[@]}" | egrep -o "$SELECTION.*" | cut -d " " -f 1-2)
        VER=$(echo "${FVER}" | cut -d " " -f 1)
        VERHASH=$(echo "${FVER}" | cut -d " " -f 2)
    else
        SELECTION="$AUTOVER"
        VER="${SELECTION/:*}"
        VERHASH="${SELECTION/*:}"
    fi
	sed -i "s/^globversion:.*/globversion: \"$VER\"/g;s/^globhash:.*/globhash: \"$VERHASH\"/g" $AINVENTORY/$TARGETENV/group_vars/all/$INSTDEF
    [ -z "$AUTOVER" ] && F_DIAERR $? "Staging splunk (VER: $VER, VERHASH: $VERHASH)"

    F_LOG $FUNCNAME "staged version: $SELECTION (FVER: $FVER, VER: $VER, VERHASH: $VERHASH)"
    F_LOG $FUNCNAME ended
}

## @fn F_UPGRADESPLC()
## @brief WIP - upgrading splunk cluster env
## @details WIP - upgrading splunk cluster env
F_UPGRADESPLC(){ 
    F_LOG $FUNCNAME started
	# ask:
	#   test? -> Major release? then: no splunk offline!
	#
	#   Upgrade all tiers at once?
	# 	Stop the master.
	#	Stop all the peers and search heads. 
	#	When bringing down the peers, use the splunk stop command, not splunk offline.
	#	Upgrade the master node, following the normal procedure for any Splunk Enterprise upgrade, as described in How to upgrade Splunk Enterprise in the Installation Manual. 
	#	Do not upgrade the peers yet.
	#	Start the master
	#	Run splunk enable maintenance-mode on the master. 
	#	To confirm that the master is in maintenance mode, run splunk show maintenance-mode
	#	Upgrade the peer nodes and search heads, following the normal procedure for any Splunk Enterprise upgrade, as described in How to upgrade Splunk Enterprise in the Installation Manual. 
	#	Start the peer nodes and search heads
	#	Run splunk disable maintenance-mode on the master. To confirm that the master is not in maintenance mode, run splunk show maintenance-mode.

	#   Upgrade each tier separately
	#	Upgrade the master node.
	#	Upgrade the search head tier:
	#		Stop all cluster members.
	#		Upgrade all members.
	#		Stop the deployer.
	#		Upgrade the deployer.
	#		Start the deployer.
	#		Start the members.
	#		Wait one to two minutes for captain election to complete. The cluster will then begin functioning.
	#	Upgrade the peer node tier
	#		Run splunk enable maintenance-mode on the master. 
	#		To confirm that the master is in maintenance mode, run splunk show maintenance-mode on the master. 
	#		Stop all the peer nodes. 
	#		When bringing down the peers, use the splunk stop command, not splunk offline.
	#		Upgrade the peer nodes, following the normal procedure for any Splunk Enterprise upgrade, as described in How to upgrade Splunk Enterprise in the Installation Manual.
	#		Start the peer nodes, if they are not already running.
	#		Run splunk disable maintenance-mode on the master.  

	# 1) MN
	# 2) SH cluster
	# 3) DEP
	# 4) Maintenance mode on
	# 5) IX cluster
	# 6) Maintenance mode off
	# 7) DS, DMC, HF, AI, LM, dev SH's
	# 8) specials: old AI (xxxxxxxxxxxxxxxxxx05), CDC SH
	# 

	F_LOG $FUNCNAME ended
}

## @fn F_SELHOST()
## @brief Show and choose host(s)
## @param 1 specify a target group directly (non interactive - will just output ALL(!) the host(s) of a group)
## @details Parsing the inventory, offering all groups found, parsing groups including childs, remove dups, offer host list and let the user choose
## @exception on abort: F_ABORTMAINMENU, on faulure: error dialog
F_SELHOST(){
        F_LOG $FUNCNAME started
        unset HOSTSELEXPANDED ABORTED HOSTSELECT HOSTFILE tgroup TGRP
	TGRP="$1"
        F_LOG $FUNCNAME "LISTTYPE=$LISTTYPE"
        [ -z "$LISTTYPE" ] && LISTTYPE=checklist && F_LOG $FUNCNAME "Using default list type: $LISTTYPE"

	if [ -z "$TGRP" ];then
	  source $AEUSRHOSTFILE
          [ -f "$HOSTFILE" ] || F_HOSTFILE
          while [ -z "$HOSTSELECT" ];do
                HOSTSELECTION=$(F_TARGETS $LISTTYPE)
                if [ "$HOSTSELECTION" == "ABORTED" ];then
                        ABORTED=1 && break
                else
                        if [ -z "$HOSTSELECTION" ];then
				F_LOG $FUNCNAME "No selection made / HOSTSELECTION empty!"
                                F_DIALOG --msgbox "ERROR: no selection made. Choose a target with space bar." 10 30
                        else
                                HOSTSELECT=1
                                ABORTED=0
                        fi
                fi
          done
	else
		HOSTSELECTION="$TGRP"
		ABORTED=0
	fi

	if [ $ABORTED -eq 1 ];then
        F_LOG $FUNCNAME "aborted by user"
		echo ABORTED
	else
		# ask for specific hosts or target group?
		unset HOSTLIST['expanded']
		if [ -z "$TGRP" ];then
			  F_DIALOG --begin 3 3 --infobox "\nPlease standby until all hostnames from your target groups are generated" 5 80 2>&1 > /dev/tty
		fi
			  for hostlist in $HOSTSELECTION;do
				if [ -z "${HOSTLIST['expanded']}" ];then
					HOSTLIST['expanded']+="$(F_EXPANDHOSTS $hostlist | grep -v EMPTY)"
				else
					HOSTLIST['expanded']+=" $(F_EXPANDHOSTS $hostlist | grep -v EMPTY)"
				fi
			  done

		unset EDITHOST
		# select hosts interactive or not depending on how we get called
		if [ -z "$TGRP" ];then
			  while [ -z "$EDITHOST" ];do
			        EDITHOST=$(F_SHOWHOSTS $LISTTYPE "${HOSTLIST['expanded']}")
				if [ -z "$EDITHOST" ];then
					F_LOG $FUNCNAME "No selection made / EDITHOST empty!"
					F_DIALOG --yesno "No selection made! Retry?" 10 40
					[ $? -ne 0 ] && F_ABORTMAINMENU
				fi
			  done
		else
			EDITHOST=$(echo "${HOSTLIST['expanded']}")
		fi
			  # make host list unique to avoid duplicated task runs when a host is in multiple groups
			  # number each entry,sort by name and remove dups, sort by num
			  echo "$EDITHOST" | tr ' ' '\n' | nl| sort -u -k2|sort -n| cut -f2-|tr '\n' ' '
	  fi
}

## @fn F_INSTALLSPL()
## @brief Install splunk on ansible prepared servers
## @exception on abort: F_ABORTMAINMENU, on failure: F_ERRLOG dialog
F_INSTALLSPL(){
        F_LOG $FUNCNAME started
	# this installs pure splunk without configuration
	
        SHOSTS="$(F_SELHOST)"
        [ "$SHOSTS" == ABORTED ] && return 4
        SHOSTST="$(echo "$SHOSTS" | sed 's/ /\n/g')"

        if  [ -z "$SHOSTS" ] || [ -z $SHOSTST ];then
                F_LOG $FUNCNAME "SHOSTS ($SHOSTS) or SHOSTST ($SHOSTST) empty"
                F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"
        else
                F_LOG $FUNCNAME "SHOSTS and SHOSTST are both set"
        fi
	
	F_LOG "$FUNCNAME" "Will install splunk on <$SHOSTS>"
	F_DIALOG --scrollbar --yesno "Will install Splunk on these hosts:\n\n$SHOSTST\n\nAre you sure?" 30 100
	[ $? -ne 0 ] && F_ABORTMAINMENU

	# create a temporary ansible group (must be in the correct env path! otherwise varibles cant be found)
	ITMPGRP=${AINVENTORY}/${TARGETENV}/${FUNCNAME}_hosts

        echo -e "[all:vars]\ntarget_env=${TARGETENV}\n" > $ITMPGRP
	echo '[tmpgrp]' >> $ITMPGRP
	for h in $SHOSTS;do echo "$h" >> $ITMPGRP; done
	if [ $? -ne 0 ];then F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"; F_ABORTMAINMENU;fi

	F_LOG "$FUNCNAME" "Temporary generated group: $(cat $ITMPGRP)"

 	F_LOG $FUNCNAME "F_A2BIN $ITMPGRP $PBINSTALL --limit tmpgrp"

	# doit
	F_A2BIN "$ITMPGRP" "$PBINSTALL" "\Za\Z1INSTALLING ...\Z\n" "--limit tmpgrp " 
        F_ERRLOG "${PIPESTATUS[0]}" "Installing splunk on:\n\n$SHOSTST" "$LOG"

	# cleanup
	[ -f $ITMPGRP ] && F_LOG $FUNCNAME "deleting temp hosts file: $(rm -vf $ITMPGRP 2>&1)"

    F_LOG $FUNCNAME ended
}

## @fn F_UPGRADEMENU()
## @brief A submenu for upgrade tasks
## @return a submenu action
## @details Shows several upgrade tasks in an own submenu
F_UPGRADEMENU(){ 
    F_LOG $FUNCNAME started
    unset SELECTION
    SELECTION=$(F_DIALOG --ok-label "Select an entry" --cancel-label "Back" --colors \
                    --menu "\nSelect an option:" \
                        20 90 80 \
                        '' '\Zb\ZuUpgrade Tasks\ZB\ZU'\
                        "" "" \
                        Download "Downloads a specific splunk version" \
                        Stage "Shows and sets a specific version for the upgrade tasks" \
                        Upgrade-Splunk "existing splunk instance(s)" \
                        Guided-Upgrade "of splunk instance(s) in a specific order" \
                        Upgrade-System "the operating system of a splunk server" \
                        "" "" \
                        "" "" \
                        3>&1 1>&2 2>&3)

    F_LOG $FUNCNAME "selected upgrade task: $SELECTION"
    if [ "$?" != "0" ]; then
              MENUDONE=1
              F_LOG $FUNCNAME "aborted by user"
              F_ABORTMAINMENU
    else
        case "$SELECTION" in
            Download)
                F_DLSPLUNK
                F_UPGRADEMENU
            ;;
            Stage)
                F_STAGESPL
                F_UPGRADEMENU
            ;;
            Upgrade-Splunk)
                F_UPGRADESPL
                F_UPGRADEMENU
            ;;
            Guided-Upgrade)
                F_GUIDEDUPGRADE
                F_UPGRADEMENU
            ;;
            Upgrade-System)
                F_SYSUPGRADE
                F_UPGRADEMENU
            ;;
            *)
                F_ABORTMAINMENU
            ;;
        esac
    fi
    F_LOG $FUNCNAME ended
}

# Upgrade splunk
F_UPGRADESPL(){
    F_LOG $FUNCNAME "started with: $@"
	# Prepare new version?
	# -> Setup the configs
	# -> Show the current staged version
	# Ask for hostfile
	# Ask for hosts OR/AND target groups?
	# Use upgrade playbook

    unset AUTOMODE PARENTPID
    
    export PARENTPID=$BASHPID

    AUTOMODE="$1"
    if [ -z "$AUTOMODE" ];then
    	UPGRADEHOSTS="$(F_SELHOST)"
        [ "$UPGRADEHOSTS" == ABORTED ] && return 4
	    CREDS=$(F_GETAPICREDS)
	    SPLUSR="${CREDS/:*}"
	    SPLPW="${CREDS/*:}"
    else
        UPGRADEHOSTS="$AUTOMODE"
    fi

	UPGRADEHOSTST="$(echo "$UPGRADEHOSTS" | sed 's/ /\n/g')"

	if  [ -z "$UPGRADEHOSTS" ] || [ -z $UPGRADEHOSTST ];then
		F_LOG $FUNCNAME "UPGRADEHOSTS ($UPGRADEHOSTS) or UPGRADEHOSTSST ($UPGRADEHOSTST) empty"
		F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"
	else
		F_LOG $FUNCNAME "UPGRADEHOSTS and UPGRADEHOSTST are both set"
	fi

	F_LOG "$FUNCNAME" "Will upgrade <$UPGRADEHOSTS>"
	F_DIALOG --scrollbar --yesno "Will upgrade Splunk on these hosts:\n\n$UPGRADEHOSTST\n\nAre you sure?" 30 100
	if [ $? -ne 0 ];then
        F_ABORTMAINMENU
    else
        if [ -z "$AUTOMODE" ];then
	        # create a temporary ansible group (must be in the correct env path! otherwise varibles cant be found)
	        UTMPGRP=${AINVENTORY}/${TARGETENV}/upgrhosts
	        echo '[tmpupgrade]' > $UTMPGRP
	        for h in $UPGRADEHOSTS;do echo "$h" >> $UTMPGRP; done
	            if [ $? -ne 0 ];then
                    F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"
                    F_ABORTMAINMENU
                else
    	            F_LOG "$FUNCNAME" "Temporary upgrade group: $(cat $UTMPGRP)"
 	                F_LOG $FUNCNAME "F_A2BIN $UTMPGRP $PBUPGRADE '--limit tmpupgrade -e \"splunk_user=$SPLUSR splunk_password=$SPLPW\"" | tee -a $LOG

	                # upgrade
	                F_A2BIN "$UTMPGRP" "$PBUPGRADE" "\Za\Z1UPGRADING ...\Z\n" "--limit tmpupgrade -e {'splunk_user':'$SPLUSR','splunk_password':'$SPLPW'}" 
                    F_ERRLOG "${PIPESTATUS[0]}" "Upgrade for:\n\n$UPGRADEHOSTST" "$LOG"
                fi
        else
            F_LOG $FUNCNAME "F_A2BIN $HOSTFILE $PBUPGRADE '--limit $AUTOMODE -e \"splunk_user=$SPLUSR splunk_password=$SPLPW\"" | tee -a $LOG
            F_A2BIN "$HOSTFILE" "$PBUPGRADE" "\Za\Z1UPGRADING ...\Z\n" "--limit $AUTOMODE -e {'splunk_user':'$SPLUSR','splunk_password':'$SPLPW'}"
            F_ERRLOG "${PIPESTATUS[0]}" "Upgrade for:\n\n$UPGRADEHOSTST" "$LOG"
        fi
    fi
    F_LOG $FUNCNAME ended
}

## @fn F_GUIDEDUPGRADE()
## @brief Guided upgrade of several splunk servers and clusters
## @exception on abort: F_ABORTMAINMENU, on failure: F_ERRLOG dialog
## @details Prepare your very own upgrade order 
F_GUIDEDUPGRADE(){
    F_LOG $FUNCNAME started


    unset HOSTSELEXPANDED ABORTED HOSTSELECT HOSTFILE tgroup TGRP
    TGRP="$1"
    if [ -z "$TGRP" ];then
       source $AEUSRHOSTFILE
       [ -f "$HOSTFILE" ] || F_HOSTFILE
       while [ -z "$HOSTSELECT" ];do
             HOSTSELECTION=$(F_TARGETS checklist)
             if [ "$HOSTSELECTION" == "ABORTED" ];then
                        ABORTED=1 && F_LOG $FUNCNAME "aborted by user" && return 4
             else
                if [ -z "$HOSTSELECTION" ];then
                        F_LOG $FUNCNAME "No selection made / HOSTSELECTION empty!"
                        F_DIALOG --msgbox "ERROR: no selection made. Choose a target with space bar." 10 30
                else
                        HOSTSELECT=1
                        ABORTED=0
                fi
              fi
        done
      else
                HOSTSELECTION="$TGRP"
                ABORTED=0
      fi

    F_LOG $FUNCNAME "hostsel: $HOSTSELECTION"

    FORMARGS='100 200 100 '

    FLINE=1
    for tg in $HOSTSELECTION;do
        FORMARGS+=' '"$tg"' '$FLINE' 1 1 '$FLINE' 20 4 3'
        FLINE=$((FLINE + 1))
    done

     F_LOG $FUNCNAME "FORMARGS: $FORMARGS"

    #UPGRADEHOSTS="$(F_SELHOST)"
    #UPGRADEHOSTST="$(echo "$UPGRADEHOSTS" | sed 's/ /\n/g')"

    #if  [ -z "$UPGRADEHOSTS" ] || [ -z $UPGRADEHOSTST ];then
    #            F_LOG $FUNCNAME "UPGRADEHOSTS ($UPGRADEHOSTS) or UPGRADEHOSTSST ($UPGRADEHOSTST) empty"
    #            F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"
    #else
    #            F_LOG $FUNCNAME "UPGRADEHOSTS and UPGRADEHOSTST are both set"
    #fi
    #F_LOG $FUNCNAME "UPGRADEHOSTS: $UPGRADEHOSTS\nUPGRADEHOSTSST: $UPGRADEHOSTST"

    UPGORDER=$(F_DIALOG --form "Puzzle your custom upgrade-run\n\nHowto:\nweight each target group with a number from 1-999. The upgrade will be done from low to high based on these numbers" \
               $FORMARGS \
               3>&1 1>&2 2>&3 )
    if [ "$UPGORDER" == "ABORTED" ];then
        F_EXIT
    fi
    SORTED=$(for num in $UPGORDER;do \
                F_LOG $FUNCNAME "prehostsel: $HOSTSELECTION"; \
                CURSEL=$(echo "$HOSTSELECTION" |cut -d ' ' -f1); \
                echo "${num}:${CURSEL}"; \
                HOSTSELECTION=$(echo "$HOSTSELECTION" | sed "s/$CURSEL //g" ); \
                F_LOG $FUNCNAME "posthostsel: $HOSTSELECTION CURSEL $CURSEL"; \
             done | sort -u |sort -n)
    
    F_LOG $FUNCNAME "UPGORDER=$UPGORDER\nSORTED: $SORTED"

    for utg in $SORTED;do
        F_UPGRADESPL "${utg/*:/}"
    done

    F_LOG $FUNCNAME ended
}

## @fn F_DEPLOYMENU()
## @brief A submenu for app deployment tasks
## @return a submenu action
## @details Shows several deployment tasks in an own submenu
F_DEPLOYMENU(){ 
    F_LOG $FUNCNAME started
    unset SELECTION DEPLOYAPPSUBSET
    SELECTION=$(F_DIALOG --ok-label "Select an entry" --cancel-label "Back" --colors \
                    --menu "\nSelect an option:" \
                        20 90 80 \
                        '' '\Zb\ZuApp-Deployment Tasks\ZB\ZU'\
                        "" "" \
                        Choose "(Re-)Deploy only specific App(s) on a target" \
                        ALL-Apps "Deploy all linked Apps of a target" \
                        "" "" \
                        "" "" \
                        3>&1 1>&2 2>&3)

    F_LOG $FUNCNAME "selected task: $SELECTION"
    if [ "$?" != "0" ]; then
              MENUDONE=1
              F_LOG $FUNCNAME "aborted by user"
              F_ABORTMAINMENU
    else
        case "$SELECTION" in
            Choose)
                DEPLOYAPPSUBSET=1 F_DEPLOYAPP
                F_DEPLOYMENU
            ;;
            ALL-Apps)
                DEPLOYAPPSUBSET=0 F_DEPLOYAPP
                F_DEPLOYMENU
            ;;
            *)
                F_ABORTMAINMENU
            ;;
        esac
    fi
    F_LOG $FUNCNAME ended
}


## @fn F_DEPLOYAPP()
## @brief Deploy Apps to (a) specified target(s)
## @details Deploy Apps to (a) specified target(s)
## 1. Ask for hostfile
## 2. update all apps based on template
## 3. re-create deploy playbook to reflect manual changes like deleting an app
## 4. Ask for target group(s) to deploy
## 5. Deploy
F_DEPLOYAPP(){ 
        F_LOG $FUNCNAME "started with: $@"
	# Ask for hostfile
	# update all apps based on template
	# re-create deploy playbook to reflect manual changes like deleting an app
	# Ask for target group(s) to deploy
	# Deploy
        echo "$FUNCNAME started" >> $LOG
        unset HOSTSELEXPANDED ABORTED HOSTSELECT HOSTFILE tgroup

        F_LOG $FUNCNAME "DEPLOYAPPSUBSET=$DEPLOYAPPSUBSET"
        FMODE=$1

        F_HOSTFILE $FMODE
        while [ -z "$HOSTSELECT" ];do
            if [ "$RUNMODE" == "interactive" ]&&[ -z "$FMODE" ];then 
                HOSTSELECTION=$(F_TARGETS checklist)
            else
                HOSTSELECTION=$(F_TARGETS checklist $BTARGET)
                SUBSETAPPS="$BDEPAPP"
            fi
            
                if [ "$HOSTSELECTION" == "ABORTED" ];then
                        ABORTED=1 && break
                else
                        if [ -z "$HOSTSELECTION" ];then
                                F_DIALOG --msgbox "ERROR: no selection made. Choose a target with space bar." 10 30
                        else
                                HOSTSELECT=1
                                ABORTED=0
                        fi
                fi
        done
	if [ "$ABORTED" -eq 0 ];then
		for rolesapp in $(find ${ROLEDIR}/apps -maxdepth 1 -type d |egrep -v "(template|file|vars|tasks)");do
			F_APPTPLUPDATE "${ROLEDIR}/apps/app.template/tasks" "$rolesapp/tasks"
		done
		F_LOG "$FUNCNAME" "Re-creating deployment playbook to reflect any manual changes.. "

        [ $DEPLOYAPPSUBSET == 0 ] && DEPTYPE="'deploy_type':'all'" && SUBSETAPPS=".*"
        if [ $DEPLOYAPPSUBSET == 1 ];then 
            LNKAPPS=$(F_LISTAPPS "$HOSTSELECTION" | cut -d ":" -f 2)
            F_LOG $FUNCNAME "Linked apps:\n$LNKAPPS"
            OPTIONS=($(for gapp in $LNKAPPS;do echo ${gapp##*/} "App" off; done))
            if [ "$RUNMODE" == "interactive" ];then
                SUBSETAPPS=$(F_DIALOG --checklist "\nPlease use the space-bar to make your selection:" 80 80 70 "${OPTIONS[@]}" 2>&1 >/dev/tty | sed 's/$/$/g;s/\ /|/g')
            fi
            F_LOG $FUNCNAME "Selected apps for deploy:\n$SUBSETAPPS"
            DEPTYPE="'deploy_type':custom,'deploy_sub_apps':'$SUBSETAPPS'"
        fi
                F_LOG $FUNCNAME "will exec: $A2BIN -i $HOSTFILE $PBREGENDEPLOY -e \"target=repository target_env=$TARGETENV $DEPTYPE\""
		F_A2BIN $HOSTFILE $PBREGENDEPLOY "Regenerating temporary deploy-app playbook.." "-e {'target':'repository','target_env':'$TARGETENV',$DEPTYPE}"
		
        DEPAPPS=$(F_LISTAPPS "$HOSTSELECTION" | cut -d ":" -f 1-2 | egrep "($SUBSETAPPS)" | sed 's/^/\\n - /g')
        F_LOG $FUNCNAME "Will deploy these apps on $HOSTSELECTION:\n$DEPAPPS"

        [ "$RUNMODE" == "interactive" ] && F_DIALOG --scrollbar --colors --yesno "ae will deploy on\Zb\Z1\n\n   $HOSTSELECTION\n\n\Znthe following apps (use Page-up/-down to scroll, select <yes> to proceed):\Zb\Z4\n$DEPAPPS\n\n\ZnAre you sure?" 40 100
        if [ $? -eq 0 ]||[ "$RUNMODE" == "batch" ];then
		    for tgroup in $HOSTSELECTION;do
			    # CHECK first!
			    F_LOG $FUNCNAME "will exec: $A2BIN --check -i $HOSTFILE $AINVENTORY/$TARGETENV/$PBDEPLAPP -e 'target=$tgroup accept_hostkey=true' --tags $tgroup"
			    #$A2BIN --check -i $HOSTFILE $AINVENTORY/$TARGETENV/$PBDEPLAPP -e "target=$tgroup accept_hostkey=true" --tags $tgroup | tee -a $LOG
			    #$A2BIN -i $HOSTFILE $AINVENTORY/$TARGETENV/$PBDEPLAPP -e "target=$tgroup accept_hostkey=true" --tags $tgroup 2>&1 | tee -a $LOG
			    F_A2BIN $HOSTFILE $AINVENTORY/$TARGETENV/$PBDEPLAPP "Deploying <$tgroup>..." "-e {'target':'$tgroup','accept_hostkey':'true'} --tags $tgroup"
                ERRCODE=$?
                F_LOG $FUNCNAME "deploying apps to $tgroup ended with $ERRCODE"
                if [ $ERRCODE -eq 0 ];then    
                    for app in $(F_LISTAPPS "$HOSTSELECTION" | cut -d ":" -f 2 | tr -d '$');do
                        APPP="$AINVENTORY/$TARGETENV/group_vars/$tgroup/$app"
                        egrep -ql "^\s*delete:\s*[Tt]rue" $APPP && F_LOG $FUNCNAME "$app has been removed on $tgroup. removing local link..." && rm -vf $APPP 2>&1 >> $LOG
                    done
                fi
			    [ "$RUNMODE" == "interactive" ] && F_ERRLOG "$ERRCODE" "<deploying apps to $tgroup>" "$LOG"
		    done
        else
            F_ERRLOG 3 "Aborted by user\n" "$LOG"
        fi
	fi
}


## @fn F_CLUSTER()
## @brief Indexer cluster menu
## @exception When no valid answer given returning to MAIN menu
## @details Provides a menu for several cluster tasks 
F_CLUSTER(){ 
        F_LOG $FUNCNAME started
	unset SELECTION
	SELECTION=$(F_DIALOG --ok-label "Select Entry" --cancel-label "Exit" --colors \
                   --menu "\nSelect an option:" \
                    	20 90 80 \
                        '' '\Zb\ZuMaintenance\ZB\ZU'\
                        "" "" \
                        OfflinePeer "NOT-READY-YET" \
                        RemovePeer "NOT-READY-YET" \
                        "" "" \
                        "" "" \
                        3>&1 1>&2 2>&3)

        if [ "$?" != "0" ]; then
              MENUDONE=1
              F_LOG $FUNCNAME "aborted by user"
              F_ABORTMAINMENU
        else
                case "$SELECTION" in
                        *)
                        F_ABORTMAINMENU
                        ;;
		esac
	fi
    F_LOG $FUNCNAME ended
}

## @fn F_CONFMENU()
## @brief Configure splunk server roles
## @exception ..
## @details Provides a menu to configure several splunk server roles
F_CONFMENU(){ 
        F_LOG $FUNCNAME started
        unset SELECTION
        SELECTION=$(F_DIALOG --ok-label "Select Entry" --cancel-label "Exit" --colors \
                   --menu "\nSelect an option:" \
                        20 90 80 \
                        '' '\Zb\ZuConfigure splunk\ZB\ZU'\
                        "" "" \
                        SearchHead "configure splunk as SearchHead" \
                        PeerNode "configure splunk as an Indexer peernode" \
                        MasterNode "configure splunk as an Indexer MasterNode" \
                        HeavyForwarder "configure splunk as Heavy Forwarder" \
                        "" "" \
                        "" "" \
                        3>&1 1>&2 2>&3)

        if [ "$?" != "0" ]; then
              MENUDONE=1
              F_LOG $FUNCNAME "aborted by user"
              F_ABORTMAINMENU
        else
                case "$SELECTION" in
                        SearchHead)
                        F_ADDSH
                        ;;
                        PeerNode)
                        F_ADDPEER
                        ;;
                        MasterNode)
                        F_ADDMN
                        ;;
                        HeavyForwarder)
                        F_ADDHF
                        ;;
                        *)
                        F_ABORTMAINMENU
                        ;;
                esac
        fi
    F_LOG $FUNCNAME ended
}

## @fn F_ADDMN()
## @brief Configures splunk to be a MasterNode
## @exception ..
## @details ..
F_ADDMN(){ 
    F_LOG $FUNCNAME started
    unset SHOSTS SHOSTST
    export LISTTYPE=radiolist

    SHOSTS="$(F_SELHOST)"
    [ "$SHOSTS" == ABORTED ] && return 4
    SHOSTST="$(echo "$SHOSTS" | sed 's/ /\n/g')"

    if  [ -z "$SHOSTS" ] || [ -z $SHOSTST ];then
            F_LOG $FUNCNAME "SHOSTS ($SHOSTS) or SHOSTST ($SHOSTST) empty"
            F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"
    else
            F_LOG $FUNCNAME "SHOSTS and SHOSTST are both set"
    fi

    F_LOG "$FUNCNAME" "Will configure indexer MasterNode on <$SHOSTS>"
    F_DIALOG --scrollbar --yesno "Will configure: \n\n$SHOSTST\n\nas indexer masternode. Are you sure?" 30 100
    [ $? -ne 0 ] && F_ABORTMAINMENU

    # create a temporary ansible group (must be in the correct env path! otherwise varibles cant be found)
    ITMPGRP=${AINVENTORY}/${TARGETENV}/${FUNCNAME}_hosts

    # target env must be set always
    echo -e "[all:vars]\ntarget_env=${TARGETENV}\n" > $ITMPGRP
    echo '[masternode]' >> $ITMPGRP
    for h in $SHOSTS;do echo "$h" >> $ITMPGRP; done
    if [ $? -ne 0 ];then F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"; F_ABORTMAINMENU;fi

    # we need the LM in any case:
    LMHOST=$(F_SELHOST licensemaster)
    echo -e '\n[licensemaster]' >> $ITMPGRP
    echo "$LMHOST" >> $ITMPGRP

    F_LOG "$FUNCNAME" "Temporary generated group: $(cat $ITMPGRP)"

    F_LOG $FUNCNAME "F_A2BIN $ITMPGRP $PBINSTALL --limit tmpgrp"

    # check ssh first
    F_CHECKSSH "$SHOSTS" "$ITMPGRP"

    # doit
    F_A2BIN "$ITMPGRP" "$PBCONFMN" "\Za\Z1Configure ...\Z\n" "--limit masternode"
    F_ERRLOG "${PIPESTATUS[0]}" "configuration as indexer MasterNode on:\n\n$SHOSTST" "$LOG"

    unset LISTTYPE
    F_LOG $FUNCNAME ended
}

## @fn F_ADDPEER()
## @brief Configures a new peer to an existing indexer cluster
## @exception ..
## @details Configures a new peer to an existing indexer cluster 
F_ADDPEER(){
        F_LOG $FUNCNAME started

	unset SHOSTS SHOSTST
        SHOSTS="$(F_SELHOST)"
        [ "$SHOSTS" == ABORTED ] && return 4
        SHOSTST="$(echo "$SHOSTS" | sed 's/ /\n/g')"

        if  [ -z "$SHOSTS" ] || [ -z $SHOSTST ];then
                F_LOG $FUNCNAME "SHOSTS ($SHOSTS) or SHOSTST ($SHOSTST) empty"
                F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"
        else
                F_LOG $FUNCNAME "SHOSTS and SHOSTST are both set"
        fi

        F_LOG "$FUNCNAME" "Will configure indexer peernode on <$SHOSTS>"
        F_DIALOG --scrollbar --yesno "Will configure: \n\n$SHOSTST\n\nas indexer peernode(s). Are you sure?" 30 100
        [ $? -ne 0 ] && F_ABORTMAINMENU

        # create a temporary ansible group (must be in the correct env path! otherwise varibles cant be found)
        ITMPGRP=${AINVENTORY}/${TARGETENV}/${FUNCNAME}_hosts

        echo -e "[all:vars]\ntarget_env=${TARGETENV}\n" > $ITMPGRP
        echo '[peernode]' >> $ITMPGRP
        for h in $SHOSTS;do echo "$h" >> $ITMPGRP; done
        if [ $? -ne 0 ];then F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"; F_ABORTMAINMENU;fi

        # we need the MN and LM in any case:
        LMHOST=$(F_SELHOST licensemaster)
        MNHOST=$(F_SELHOST masternode)
        echo -e '\n[masternode]' >> $ITMPGRP
        echo "$MNHOST" >> $ITMPGRP
        echo -e '\n[licensemaster]' >> $ITMPGRP
        echo "$LMHOST" >> $ITMPGRP

        F_LOG "$FUNCNAME" "Temporary generated group: $(cat $ITMPGRP)"

        F_LOG $FUNCNAME "F_A2BIN $ITMPGRP $PBINSTALL --limit tmpgrp"

        # doit
        F_A2BIN "$ITMPGRP" "$PBCONFPEER" "\Za\Z1Configure ...\Z\n" "--limit peernode"
        F_ERRLOG "${PIPESTATUS[0]}" "configuration as indexer peernode on:\n\n$SHOSTST" "$LOG"

        F_LOG $FUNCNAME ended	
}

## @fn F_ADDSH()
## @brief Configures splunk to be a SearchHead
## @exception ..
## @details ..
F_ADDSH(){ 
    F_LOG $FUNCNAME started
    unset SHOSTS SHOSTST

    SHOSTS="$(F_SELHOST)"
    [ "$SHOSTS" == ABORTED ] && return 4
    SHOSTST="$(echo "$SHOSTS" | sed 's/ /\n/g')"

    if  [ -z "$SHOSTS" ] || [ -z $SHOSTST ];then
            F_LOG $FUNCNAME "SHOSTS ($SHOSTS) or SHOSTST ($SHOSTST) empty"
            F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"
    else
            F_LOG $FUNCNAME "SHOSTS and SHOSTST are both set"
    fi

    F_LOG "$FUNCNAME" "Will configure <$SHOSTS> as a SearchHead"
    F_DIALOG --scrollbar --yesno "Will configure: \n\n$SHOSTST\n\nas SearchHead(s). Are you sure?" 30 100
    [ $? -ne 0 ] && F_ABORTMAINMENU

    # create a temporary ansible group (must be in the correct env path! otherwise varibles cant be found)
    ITMPGRP=${AINVENTORY}/${TARGETENV}/${FUNCNAME}_hosts

    echo -e "[all:vars]\ntarget_env=${TARGETENV}\n" > $ITMPGRP
    echo '[searchhead]' >> $ITMPGRP
    for h in $SHOSTS;do echo "$h" >> $ITMPGRP; done
    if [ $? -ne 0 ];then F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"; F_ABORTMAINMENU;fi

    # we need the MN and LM in any case:
    LMHOST=$(F_SELHOST licensemaster)
    MNHOST=$(F_SELHOST masternode)
    PNHOST=$(F_SELHOST peernode)
    echo -e '\n[peernode]' >> $ITMPGRP
    for h in $PNHOST ;do
        echo "$h" >> $ITMPGRP
    done
    echo -e '\n[masternode]' >> $ITMPGRP
    echo "$MNHOST" >> $ITMPGRP
    echo -e '\n[licensemaster]' >> $ITMPGRP
    echo "$LMHOST" >> $ITMPGRP

    F_LOG "$FUNCNAME" "Temporary generated group: $(cat $ITMPGRP)"

    # doit
    F_A2BIN "$ITMPGRP" "$PBCONFSH" "\Za\Z1Configure ...\Z\n" "--limit searchhead"
    F_ERRLOG "${PIPESTATUS[0]}" "configuration as SearchHead on:\n\n$SHOSTST" "$LOG"

    F_LOG $FUNCNAME ended
}

## @fn F_ADDHF()
## @brief Configures splunk to be a Heavy Forwarder
## @exception ..
## @details ..
F_ADDHF(){ 
    F_LOG $FUNCNAME started
    unset SHOSTS SHOSTST

    SHOSTS="$(F_SELHOST)"
    [ "$SHOSTS" == ABORTED ] && return 4
    SHOSTST="$(echo "$SHOSTS" | sed 's/ /\n/g')"

    if  [ -z "$SHOSTS" ] || [ -z $SHOSTST ];then
            F_LOG $FUNCNAME "SHOSTS ($SHOSTS) or SHOSTST ($SHOSTST) empty"
            F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"
    else
            F_LOG $FUNCNAME "SHOSTS and SHOSTST are both set"
    fi

    F_LOG "$FUNCNAME" "Will configure <$SHOSTS> as a Heavy Forwarder"
    F_DIALOG --scrollbar --yesno "Will configure: \n\n$SHOSTST\n\nas Heavy Forwarder(s). Are you sure?" 30 100
    [ $? -ne 0 ] && F_ABORTMAINMENU

    # create a temporary ansible group (must be in the correct env path! otherwise variables cant be found)
    ITMPGRP=${AINVENTORY}/${TARGETENV}/${FUNCNAME}_hosts

    echo -e "[all:vars]\ntarget_env=${TARGETENV}\n" > $ITMPGRP
    echo '[heavyforwarder]' >> $ITMPGRP
    for h in $SHOSTS;do echo "$h" >> $ITMPGRP; done
    if [ $? -ne 0 ];then F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"; F_ABORTMAINMENU;fi

    # we need the MN and LM in any case:
    LMHOST=$(F_SELHOST licensemaster)
    MNHOST=$(F_SELHOST masternode)
    PNHOST=$(F_SELHOST peernode)
    echo -e '\n[peernode]' >> $ITMPGRP
    for h in $PNHOST ;do
        echo "$h" >> $ITMPGRP
    done
    echo -e '\n[masternode]' >> $ITMPGRP
    echo "$MNHOST" >> $ITMPGRP
    echo -e '\n[licensemaster]' >> $ITMPGRP
    echo "$LMHOST" >> $ITMPGRP

    F_LOG "$FUNCNAME" "Temporary generated group: $(cat $ITMPGRP)"

    # doit
    F_A2BIN "$ITMPGRP" "$PBCONFHF" "\Za\Z1Configure ...\Z\n" "--limit heavyforwarder"
    F_ERRLOG "${PIPESTATUS[0]}" "configuration as Heavy Forwarder on:\n\n$SHOSTST" "$LOG"

    F_LOG $FUNCNAME ended
}


## @fn F_VAULTPW()
## @brief Ask for the Vault password if required
## @exception ..
## @details Ansible Vault dialog to grab the pass and store it temporary
## After using this you HAVE TO ensure using F_RMVAULTPW after the pw file is not needed anymore.
F_VAULTPW(){ 
    F_LOG $FUNCNAME started

    RETRY=1

    # skip if vault tmp file exists
    [ -s "$VAULTTEMPFILE" ] && return 0

    while [ $RETRY -ne 0 ];do
        FPW=$(F_DIALOG --insecure --mixedform \
                "\nAnsible Vault is enabled (ENABLEVAULT variable).\nPlease type in the Vault password to unlock protected variables:\n" 10 80 0 \
                "Password:" 1 1 '' 1 20 20 0 1 \
                 2>&1 >/dev/tty)
        [ $? -ne 0 ] && F_LOG $FUNCNAME "Aborted by user" && return 4
        SPW=$(F_DIALOG --insecure --mixedform "\nPlease re-type the Vault password for verification:\n" 10 80 0 "Password:" 1 1 '' 1 20 20 0 1  2>&1 >/dev/tty)
        [ $? -ne 0 ] && F_LOG $FUNCNAME "Re-typing aborted by user" && return 5

        if [ "$FPW" != "$SPW" ];then 
            RETRY=1
            F_DIAERR 9 "ERROR: Passwords do not match. Try again.."
            unset FPW SPW
        else
            RETRY=0
        fi
    done

    # write the vault temp file
    echo "$FPW" > $VAULTTEMPFILE

    F_LOG $FUNCNAME ended
}

## @fn F_VCDEFS()
## @brief Collects every AE relevant vCenter information
## @details Connects to a given vCenter and stores all collected stuff in 
## $AINVENTORY/$TARGETENV/vmware (defined in $PBVCINFO playbook)
F_VCDEFS(){ 
    F_LOG $FUNCNAME started
    F_A2BIN $HOSTFILE $PBVCSHOW "Collecting vCenter definitions..."
    F_LOG $FUNCNAME ended
}

## @fn F_VCGETINFO()
## @brief Collects and sets every AE relevant vCenter information
## @details Connects to a given vCenter and stores all collected stuff in 
## $AINVENTORY/$TARGETENV/tmp (defined in $PBVCINFO playbook) and let the user choose from it
F_VCGETINFO(){ 
    F_LOG $FUNCNAME started
    VCWORKDIR="$AINVENTORY/$TARGETENV/tmp"

    F_LOG $FUNCNAME $VMCPU

    # collect configured vcenter definitions
    F_VCDEFS

    OPTIONS=($(for i in $(cat $VCWORKDIR/vcenters.list);do echo "${i/*:}" "${i/:*}" off;done))
    VCENTER=$(F_DIALOG --radiolist \
            "\nThese are the currently defined vCenters\n($INVENTORY/$TARGETENV/group_vars/all/bare_install)\n\nPlease use the space-bar to make your selection:" \
            80 80 70 \
            "${OPTIONS[@]}" \
            2>&1 >/dev/tty)
    [ $? -ne 0 ] && F_DIAERR 9 "Aborted by user" && break

    F_LOG $FUNCNAME "Choosen vCenter was: $VCENTER"   
 
    # check previous lists, if one of them is not here or 0 bytes a refresh will be forced
    VCLIST="$VCWORKDIR/vcenters.list"
    VCHOSTLIST="$VCWORKDIR/${VCENTER}_vchosts.list"
    VCNETLIST="$VCWORKDIR/${VCENTER}_networks.list"
    VCDCLIST="$VCWORKDIR/${VCENTER}_datacenters.list"
    VCDSLIST="$VCWORKDIR/${VCENTER}_datastores.list"
    VCREFRESH=0

    for list in $VCLIST $VCHOSTLIST $VCNETLIST $VCDCLIST $VCDSLIST; do
        LISTSAVAIL=0
        F_LOG $FUNCNAME "CHECK: $list ..."
        test -s $list || break
        F_LOG $FUNCNAME "CHECK: $list exists already and is not 0 bytes..."
        LISTSAVAIL=1
    done
    F_LOG $FUNCNAME "LISTSAVAIL ended with $LISTSAVAIL"

    if [ $LISTSAVAIL -eq 1 ];then
        F_DIALOG --colors --yesno "\nAE has detected cached vCenter information for:\n\n     \Zb$VCENTER\ZB\n\nDo you want to use the cache (choose: yes)\nor force a refresh (choose: no)?\n" 13 80
        VCREFRESH=$?
    fi
    if [ $LISTSAVAIL -eq 0 -o $VCREFRESH -eq 1 ];then
        F_A2BIN $HOSTFILE $PBVCINFO "Collecting vCenter information ..." "-e {'vsphere_var':'$VCENTER'}"
    else
        F_LOG $FUNCNAME "Using cached vCenter lists"
    fi

    for list in $VCLIST $VCHOSTLIST $VCNETLIST $VCDCLIST $VCDSLIST; do
        LISTSAVAIL=0
        F_LOG $FUNCNAME "CHECK: $list ..."
        test -s $list || break
        F_LOG $FUNCNAME "CHECK: $list exists already and is not 0 bytes..."
        LISTSAVAIL=1
    done
    F_LOG $FUNCNAME "LISTSAVAIL ended with $LISTSAVAIL"

    if [ $LISTSAVAIL -ne 1 ];then
        F_ERRLOG "9" "Error collecting ESX information!" "$LOG"
        F_ABORTMAINMENU
    fi

    # Target ESX
    FINISHED=0
    while [ $FINISHED -eq 0 ];do
        OPTIONS=($(for i in $(tail -n +2 $VCHOSTLIST);do echo "${i/;*}" "${i/*;}" off;done))
        VCHOST=$(F_DIALOG --colors --radiolist \
            "\nThe following ESX hosts are handled by the choosen vCenter:\n\n    \Zb$VCENTER\ZB\n\nWhich one of the following should be used for provisioning\n(space-bar selects)?\n" \
            100 80 100 \
            "${OPTIONS[@]}" \
            2>&1 >/dev/tty)
        [ $? -ne 0 ] && F_DIAERR $? "Aborted by user" && break 99
        F_LOG $FUNCNAME "Choosen: $VCHOST"
        HOSTFILTER=$(echo $VCHOST | cut -d "." -f1)
        [ ! -z "$VCHOST" ] && FINISHED=1
    done

    # Target Network name
    FINISHED=0
    while [ $FINISHED -eq 0 ];do
        OPTIONS=($(for i in $(tail -n +2 $VCNETLIST );do echo "${i/;*}" "${i/;*}" off;done))
        VCNET=$(F_DIALOG --colors --radiolist \
            "\nThe following Networks are handled by the choosen vCenter:\n\n    \Zb$VCENTER\ZB\n\nWhich one of the following should be used for provisioning\n(space-bar selects)?\n" \
            100 80 100 \
            "${OPTIONS[@]}" \
            2>&1 >/dev/tty)
        [ $? -ne 0 ] && F_DIAERR $? "Aborted by user" && break 99
        F_LOG $FUNCNAME "Choosen: $VCNET"   
        [ ! -z "$VCNET" ] && FINISHED=1
    done

    # Target Datacenter name
    FINISHED=0
    while [ $FINISHED -eq 0 ];do
        OPTIONS=($(for i in $(tail -n +2 $VCDCLIST );do echo "${i/;*}" "${i/;*}" off;done))
        VCDC=$(F_DIALOG --colors --radiolist \
            "\nThe following Datacenters are handled by the choosen vCenter:\n\n    \Zb$VCENTER\ZB\n\nWhich one of the following should be used for provisioning\n(space-bar selects)?\n" \
            100 80 100 \
            "${OPTIONS[@]}" \
            2>&1 >/dev/tty)
        [ $? -ne 0 ] && F_DIAERR $? "Aborted by user" && break 99
        F_LOG $FUNCNAME "Choosen: $VCDC"
        [ ! -z "$VCDC" ] && FINISHED=1
    done

    # Target Datastore name
    FINISHED=0
    while [ $FINISHED -eq 0 ];do
        OPTIONS=($(for i in $(tail -n +2 $VCDSLIST);do free_gb=$((${i/*;}/1024/1024/1024)) ; echo "${i/;*}" "Free=${free_gb}GB" off;done))
        VCDS=$(F_DIALOG --colors --radiolist \
            "\nThe following Datastorages are handled by the choosen vCenter (\Zb$VCENTER\ZB)\nWhich one of the following should be used for provisioning\n(space-bar selects)?\n\nThe datastorage to store the\n\n   \ZbOperating System\ZB\n\n should be:\n" \
            100 80 100 \
            "${OPTIONS[@]}" \
            2>&1 >/dev/tty)
        [ $? -ne 0 ] && F_DIAERR $? "Aborted by user" && break 99
        F_LOG $FUNCNAME "Choosen: $VCDS"   
        [ ! -z "$VCDS" ] && FINISHED=1
    done

    # DEPLOY IT
    F_DEPLOYVMDO
    ERR=$?
    F_LOG $FUNCNAME "F_DEPLOYVMDO ended with $ERR"
    return $ERR

    F_LOG $FUNCNAME ended
} 

## @fn F_DEPLOYVMDO()
## @brief Deploys the VM
## @exception ..
## @details The actual doing is done here while it all starts in F_DEPLOYVM
F_DEPLOYVMDO(){ 
    F_LOG $FUNCNAME started

    F_LOG "$FUNCNAME" "VCENTER,VMHOST,VMCPU,VMRAM,VMIP,VMNETMASK,VMGW,VMDNS1,VMDNS2,VMSDOMAIN,VCHOST,VCDC,VCDS,VCNET,VMGUESTOS,VMDISK,VMDISKTYPE,VMDISKSIZEGB,VMDISKOPTS,VMDISKDEV"
    F_LOG "$FUNCNAME" "$VCENTER,$VMHOST,$VMCPU,$VMRAM,$VMIP,$VMNETMASK,$VMGW,$VMDNS1,$VMDNS2,$VMSDOMAIN,$VCHOST,$VCDC,$VCDS,$VCNET,$VMGUESTOS,$VMDISK,$VMDISKTYPE,$VMDISKSIZEGB,$VMDISKOPTS,$VMDISKDEV"

    if [ -z "$VMHOST" -o -z "$VMCPU" -o -z "$VMRAM" -o -z "$VMIP" -o -z "$VMNETMASK" -o -z "$VMGW" -o -z "$VMDNS1" -o -z "$VMDNS2" -o -z "$VMSDOMAIN" -o -z "$VCHOST" -o -z "$VCDC" -o -z "$VCDS" -o -z "$VCNET" ];then
        F_DIAERR 9 "A required field is missing! ABORTED."
        F_LOG $FUNCNAME "ERROR: A required field is missing!"
        F_ABORTMAINMENU
    else            
        ABORTED=0
    fi

    # make all user defined settings available here
    source $TMPHWPROFILE

    # sum up (makes uses of real tab spaces in dialog):
    F_DIALOG --no-collapse --colors --yesno "\nAE is about to provision a VM with the following details:\n\n    vCenter:"$'\t\t'"\Zb$VCENTER\ZB\n    ESX:"$'\t\t'"$VCHOST\n\n    Hostname:"$'\t\t'"${VMHOST}.${VMSDOMAIN}\n    CPU:"$'\t\t'"$VMCPU\n    RAM (MB):"$'\t\t'"$VMRAM\n    IP:"$'\t\t'"$VMIP/$VMNETMASK\n    Gateway:"$'\t\t'"$VMGW\n    DNS servers:"$'\t'"$VMDNS1, $VMDNS2\n    Datacenter:"$'\t'"$VCDC\n    Datastorage:"$'\t'"$VCDS\n    Network:"$'\t\t'"$VCNET\n\nDo you want to continue?\n" 50 80
    DEPLOYIT=$?

    [ $DEPLOYIT -ne 0 ] && F_LOG $FUNCNAME "Aborted by user" && break 99

    F_LOG $FUNCNAME "Will start provisionining with: $PBVCVMDEPLOY -e {'vsphere_var':'$VCENTER','server_hostname':'$VMHOST','server_ram_mb':'$VMRAM','server_cpu_count':'$VMCPU','server_ip':'$VMIP','server_netmask':'$VMNETMASK','server_gateway':'$VMGW','server_dns1':'$VMDNS1','server_dns2':'$VMDNS2','server_domain':'$VMSDOMAIN','vsphere_esx_host':'$VCHOST','vsphere_datacenter':'$VCDC','server_net_name':'$VCNET','vsphere_datastore':'$VCDS','vsphere_guestos':'$VMGUESTOS', 'server_scnd_disk':'$VMDISK','server_disk_type':'$VMDISKTYPE','server_disk_sizegb':'$VMDISKSIZEGB'}"

    F_A2BIN $HOSTFILE $PBVCVMDEPLOY "Deploying $VMHOST to $VCHOST ..." "--limit ${VMHOST}.${VMSDOMAIN} -e {'vsphere_var':'$VCENTER','server_hostname':'$VMHOST','server_ram_mb':'$VMRAM','server_cpu_count':'$VMCPU','server_ip':'$VMIP','server_netmask':'$VMNETMASK','server_gateway':'$VMGW','server_dns1':'$VMDNS1','server_dns2':'$VMDNS2','server_domain':'$VMSDOMAIN','vsphere_esx_host':'$VCHOST','vsphere_datacenter':'$VCDC','server_net_name':'$VCNET','vsphere_datastore':'$VCDS','vsphere_guestos':'$VMGUESTOS','server_scnd_disk':'$VMDISK'}" 
#2>&1 >> $LOG
    DEPERR=$?
    F_LOG $FUNCNAME "deploying ended with code: $DEPERR"
    F_DIAERR $DEPERR "Deploying $VMHOST to $VCENTER" 
    [ $DEPERR -ne 0 ] && return 99

    if [ $DEPERR -eq 0 ]&&[ "$VMDISK" -ne 0 ];then
        # add as many disk(s) as needed

        VMDISKCNT=0
        while [ $VMDISKCNT -ne $VMDISK ];do
            VMDISKCNT=$((VMDISKCNT +1))

            # dynamic variable names..
            VMDISKTYPE="VMDISK${VMDISKCNT}TYPE"
            VMDISKSIZEGB="VMDISK${VMDISKCNT}SIZEGB"
            VMDISKDEV="VMDISK${VMDISKCNT}DEV"

            VMDISKOPTS="VMDISK${VMDISKCNT}OPTS"
            VMDISKFS="VMDISK${VMDISKCNT}FS"
            VMDISKMNTP="VMDISK${VMDISKCNT}MNTP"
            VMDISKLVMVG="VMDISK${VMDISKCNT}LVMVG"
            VMDISKLVMLV="VMDISK${VMDISKCNT}LVMLV"

            # Target Datastore name
            FINISHED=0    
            while [ $FINISHED -eq 0 ];do        
                OPTIONS=($(for i in $(tail -n +2 $VCDSLIST);do free_gb=$((${i/*;}/1024/1024/1024)) ; echo "${i/;*}" "Free=${free_gb}GB" off;done))
                VCDS=$(F_DIALOG --colors --radiolist \
                "\nThe following Datastorages are handled by the choosen vCenter ($VCENTER)\n\nWhich one of the following should be used for\n\n  \Zb${!VMDISKDEV} - ${!VMDISKMNTP} (${!VMDISKSIZEGB} GB)\ZB\n\n(space-bar selects)?\n" \
                100 80 100 \
                "${OPTIONS[@]}" \
                2>&1 >/dev/tty)
                [ $? -ne 0 ] && F_DIAERR $? "Aborted by user" && break 99
                F_LOG $FUNCNAME "Choosen: $VCDS"
                [ ! -z "$VCDS" ] && FINISHED=1
            done

            # sum up (makes uses of real tab spaces in dialog):
            F_DIALOG --no-collapse --colors --yesno "\nAE is about to add a new disk to VM $VMHOST with the following details:\n\n    vCenter:"$'\t\t'"\Zb$VCENTER\ZB\n    ESX:"$'\t\t'"$VCHOST\n\n    Hostname:"$'\t\t'"${VMHOST}.${VMSDOMAIN}\n    Disk path:"$'\t'"${!VMDISKDEV}\n    Size (GB):"$'\t'"${!VMDISKSIZEGB}\n    Filesystem:"$'\t'"${!VMDISKFS}\n    Type:"$'\t\t'"${!VMDISKTYPE}\n    Mountpoint:"$'\t'"${!VMDISKMNTP}\n    Mount options:"$'\t'"${!VMDISKOPTS}\n    LVM VG name: "$'\t'"${!VMDISKLVMVG}\n    LVM LV name: "$'\t'"${!VMDISKLVMLV}\n    Datacenter:"$'\t'"$VCDC\n    Datastorage:"$'\t'"$VCDS\n\nDo you want to continue?\n" 50 80
            DEPLOYIT=$?

            [ $DEPLOYIT -ne 0 ] && F_LOG $FUNCNAME "Aborted by user" && return 99

            F_LOG $FUNCNAME "additional disk config needed. disks left: $VMDISK"
            F_A2BIN $HOSTFILE $PBVMNEWDISK "Adding a new disk to $VMHOST ..." "--limit ${VMHOST}.${VMSDOMAIN} -e {'vsphere_var':'$VCENTER','server_hostname':'$VMHOST','vsphere_esx_host':'$VCHOST','vsphere_datacenter':'$VCDC','vsphere_datastore':'$VCDS','server_scnd_disk':'$VMDISK','server_disk_type':'${!VMDISKTYPE}','server_scsi_controller':'$VMSCSI','server_disk_num':'$VMDISKCNT','server_disk_sizegb':'${!VMDISKSIZEGB}','server_disk_dev':'${!VMDISKDEV}'}"
            ADDERR=$?
            [ $ADDERR -ne 0 ] && F_LOG $FUNCNAME "error $ADDERR occured" && return $ADDERR

            F_LOG $FUNCNAME "additional disk config needed. disks left: $(($VMDISK - $VMDISKCNT))" 
        done
        VMDISKCNT=0
        while [ $VMDISKCNT -ne $VMDISK ];do
            VMDISKCNT=$((VMDISKCNT +1))
            
            # dynamic variable names..
            VMDISKDEV="VMDISK${VMDISKCNT}DEV"
            VMDISKOPTS="VMDISK${VMDISKCNT}OPTS"
            VMDISKFS="VMDISK${VMDISKCNT}FS"
            VMDISKMNTP="VMDISK${VMDISKCNT}MNTP"
            VMDISKLVMVG="VMDISK${VMDISKCNT}LVMVG"
            VMDISKLVMLV="VMDISK${VMDISKCNT}LVMLV"
            VMDISKTYPE="VMDISK${VMDISKCNT}TYPE"
            VMDISKSIZEGB="VMDISK${VMDISKCNT}SIZEGB"
   
            F_A2BIN $HOSTFILE $PBVMDISKFORMAT "Formatting \Zb${!VMDISKDEV}\ZB on $VMHOST ..." "--limit ${VMHOST}.${VMSDOMAIN} -e {'vsphere_var':'$VCENTER','server_hostname':'$VMHOST','vsphere_esx_host':'$VCHOST','vsphere_datacenter':'$VCDC','vsphere_datastore':'$VCDS','server_scnd_disk':'$VMDISK','server_disk_type':'${!VMDISKTYPE}','server_disk_sizegb':'${!VMDISKSIZEGB}','server_disk_mountopts':'${!VMDISKOPTS}','server_disk_dev':'${!VMDISKDEV}','server_disk_fs':'${!VMDISKFS}','server_disk_mountpoint':'${!VMDISKMNTP}','server_lvm_vg':'${!VMDISKLVMVG}','server_lvm_lv':'${!VMDISKLVMLV}'}"
            ERR=$?
            [ $ERR -ne 0 ] && F_LOG $FUNCNAME "error $ERR occured" && return $ERR
            
       done
    else
        F_LOG $FUNCNAME "No additional disk config needed"
    fi

    F_LOG $FUNCNAME ended
}

## @fn F_DEPLOYVM()
## @brief Deploy a new blank VM based on a template
## @exception ..
## @details The VM template used to clone 
## should be setup and prepared in a a way that ansible is able
## to connect and work with afterwards.
## Only vSphere ESX is supported.
F_DEPLOYVM(){ 
    F_LOG $FUNCNAME started

    unset SROLE

    FINISHED=0
    ABORTED=0

    HWCONFIG="$ADIR/vmware/splunk_hardware-defaults_"

    for srole in $(cat ${HWCONFIG}*.config |grep "SERVER_ROLE" | cut -d "=" -f 2);do
        SROLE="$SROLE $srole"
    done

    F_LOG $FUNCNAME "Detected hardware profiles: $SROLE"
    
    while [ $FINISHED -eq 0 ];do
        OPTIONS=($(for i in $SROLE;do echo "$i" "$i" off;done))
        HWPROFILE=$(F_DIALOG --colors --radiolist \
            "\nSplunk VMware hardware profiles have been found.\nSelect any (space-bar) or choose 'Empty' \nif you want to start with an empty template:\n" \
            100 80 100 \
            "${OPTIONS[@]}" \
            "Empty" "Empty template " off \
            2>&1 >/dev/tty)

        [ ! -z "$HWPROFILE" ] && FINISHED=1
    done
    F_LOG $FUNCNAME "Choosen hardware profile: $HWPROFILE"
    FINISHED=0

    if [ "$HWPROFILE" != "Empty" ];then
        if [ ! -f ${HWCONFIG}${HWPROFILE}.config ];then
            F_ERRLOG 9 "Cannot find ${HWCONFIG}${HWPROFILE}.config!"
            TMPHWPROFILE="$ADIR/vmware/${FUNCNAME}_empty.config"
            > $TMPHWPROFILE
        else
            source "${HWCONFIG}${HWPROFILE}.config"
            F_LOG $FUNCNAME "Loading $HWPROFILE template.."
            TMPHWPROFILE="$ADIR/vmware/${FUNCNAME}_${HWPROFILE}.config"
            cp ${HWCONFIG}${HWPROFILE}.config $TMPHWPROFILE
        fi
    fi

    # default SCSI controller if not set in the HW profile
    [ -z "$VMSCSI" ] && VMSCSI=0
    # default mount options when additional disk
    [ -z "$VMDISKOPTS" ] && VMDISKOPTS="defaults"

    while [ $FINISHED -eq 0 ];do
        DIAOUT=$(F_DIALOG --form "\nSetup your new VM - Use arrow keys to switch between\n(no validation so be careful what you type..)" 30 100 20  \
                "Hostname" 1 1 "$VMHOST" 1 20 70 60  \
                "Server Domain Name" 2 1 "$VMSDOMAIN" 2 20 70 60 \
                "CPU count" 3 1 "$VMCPU" 3 20 4 3 \
                "RAM (MB)" 4 1 "$VMRAM" 4 20 10 10 \
                "Host IP" 5 1 "$VMIP" 5 20 27 28 \
                "Netmask (x.x.x.x)" 6 1 "$VMNETMASK" 6 20 27 28 \
                "Gateway IP" 7 1 "$VMGW" 7 20 27 28 \
                "DNS #1" 8 1 "$VMDNS1" 8 20 27 28 \
                "DNS #2" 9 1 "$VMDNS2" 9 20 27 28 \
                3>&1 1>&2 2>&3)

        [ $? -ne 0 ] && F_LOG $FUNCNAME "aborted by user" && ABORTED=1 && FINISHED=1 && break
        F_LOG $FUNCNAME "diaout:\n$DIAOUT"

        # normalize the output so it can be parsed correctly
        NDIAOUT=$(echo -e "$DIAOUT" | tr "\n" "|")
        
        VMHOST=$(echo $NDIAOUT | cut -d "|" -f1 | tr -d " ")
        VMSDOMAIN=$(echo $NDIAOUT | cut -d "|" -f2 | tr -d " ")
        VMCPU=$(echo $NDIAOUT | cut -d "|" -f3 | tr -d " ")
        VMRAM=$(echo $NDIAOUT | cut -d "|" -f4 | tr -d " ")
        VMIP=$(echo $NDIAOUT | cut -d "|" -f5 | tr -d " ")
        VMNETMASK=$(echo $NDIAOUT | cut -d "|" -f6 | tr -d " ")
        VMGW=$(echo $NDIAOUT | cut -d "|" -f7 | tr -d " ")
        VMDNS1=$(echo $NDIAOUT | cut -d "|" -f8 | tr -d " ")
        VMDNS2=$(echo $NDIAOUT | cut -d "|" -f9 | tr -d " ")

        F_LOG "$FUNCNAME" "VMHOST,VMCPU,VMRAM,VMIP,VMNETMASK,VMGW,VMDNS1,VMDNS2,VMSDOMAIN"
        F_LOG "$FUNCNAME" "$VMHOST,$VMCPU,$VMRAM,$VMIP,$VMNETMASK,$VMGW,$VMDNS1,$VMDNS2,$VMSDOMAIN"

        if [ -z "$VMHOST" -o -z "$VMCPU" -o -z "$VMRAM" -o -z "$VMIP" -o -z "$VMNETMASK" -o -z "$VMGW" -o -z "$VMDNS1" -o -z "$VMDNS2" -o -z "$VMSDOMAIN" ];then
            F_DIAERR 9 "A required field is missing.. try again"
            F_LOG $FUNCNAME "ERROR: A required field is missing!"
            VMERR=99
        else
            FINISHED=1
            VMERR=0
        fi

        # add as many disk(s) as needed
        if [ $VMERR -eq 0 ]&&[ "$VMDISK" -ne 0 ];then
            echo "\n\n# The following may override the above defaults\n" >> $TMPHWPROFILE
            echo "VMHOST='$VMHOST'" >> $TMPHWPROFILE
            echo "VMCPU='$VMCPU'" >> $TMPHWPROFILE
            echo "VMRAM='$VMRAM'" >> $TMPHWPROFILE
            echo "VMIP='$VMIP'" >> $TMPHWPROFILE
            echo "VMNETMASK='$VMNETMASK'" >> $TMPHWPROFILE
            echo "VMGW='$VMGW'" >> $TMPHWPROFILE
            echo "VMDNS1='$VMDNS1'" >> $TMPHWPROFILE
            echo "VMDNS2='$VMDNS2'" >> $TMPHWPROFILE
            echo "VMSDOMAIN='$VMSDOMAIN'" >> $TMPHWPROFILE

            VMDISKCNT=0
            while [ $VMDISKCNT -ne $VMDISK ];do
                VMDISKCNT=$((VMDISKCNT +1))

                # dynamic variable names..
                VMDISKTYPE="VMDISK${VMDISKCNT}TYPE"
                VMDISKSIZEGB="VMDISK${VMDISKCNT}SIZEGB"
                VMDISKOPTS="VMDISK${VMDISKCNT}OPTS"
                VMDISKDEV="VMDISK${VMDISKCNT}DEV"
                VMDISKFS="VMDISK${VMDISKCNT}FS"
                VMDISKMNTP="VMDISK${VMDISKCNT}MNTP"
                VMDISKLVMVG="VMDISK${VMDISKCNT}LVMVG"
                VMDISKLVMLV="VMDISK${VMDISKCNT}LVMLV"

                DIAOUT=$(F_DIALOG --form "\nSetup your new disk ($VMDISKCNT of $VMDISK) for $VMHOST- Use arrow keys to switch between\n(no validation so be careful what you type..)" 20 100 10  \
                            "Physical device path within the VM" 1 1 "${!VMDISKDEV}" 1 42 40 40  \
                            "Filesystem to use (xfs,ext4,..)" 2 1 "${!VMDISKFS}" 2 42 40 20  \
                            "Disk size in GB" 3 1 "${!VMDISKSIZEGB}" 3 42 40 20 \
                            "Disk type (thin|eagerzeroedthick|thick)" 4 1 "${!VMDISKTYPE}" 4 42 40 16 \
                            "Mountpoint" 5 1 "${!VMDISKMNTP}" 5 42 40 40 \
                            "LVM VG name" 6 1 "${!VMDISKLVMVG}" 6 42 40 40 \
                            "LVM LV name" 7 1 "${!VMDISKLVMLV}" 7 42 40 40 \
                            "Mount options" 8 1 "${!VMDISKOPTS}" 8 42 40 100 \
                            3>&1 1>&2 2>&3)

                # normalize the output so it can be parsed correctly
                NDIAOUT=$(echo -e "$DIAOUT" | tr "\n" "|")

                UVMDISKDEV=$(echo "$NDIAOUT" | cut -d "|" -f 1 | tr -d " ")
                UVMDISKFS=$(echo "$NDIAOUT" | cut -d "|" -f 2 | tr -d " ")
                UVMDISKSIZEGB=$(echo "$NDIAOUT" | cut -d "|" -f 3 | tr -d " ")
                UVMDISKTYPE=$(echo "$NDIAOUT" | cut -d "|" -f 4 | tr -d " ")
                UVMDISKMNTP=$(echo "$NDIAOUT" | cut -d "|" -f 5 | tr -d " ")
                UVMDISKLVMVG=$(echo "$NDIAOUT" | cut -d "|" -f 6 | tr -d " ")
                UVMDISKLVMLV=$(echo "$NDIAOUT" | cut -d "|" -f 7 | tr -d " ")
                UVMDISKOPTS=$(echo "$NDIAOUT" | cut -d "|" -f 8 | tr -d " ")

                echo "VMDISK${VMDISKCNT}TYPE=${UVMDISKTYPE}" >> $TMPHWPROFILE
                echo "VMDISK${VMDISKCNT}FS=${UVMDISKFS}" >> $TMPHWPROFILE
                echo "VMDISK${VMDISKCNT}SIZEGB=${UVMDISKSIZEGB}" >> $TMPHWPROFILE
                echo "VMDISK${VMDISKCNT}OPTS=${UVMDISKOPTS}" >> $TMPHWPROFILE
                echo "VMDISK${VMDISKCNT}DEV=${UVMDISKDEV}" >> $TMPHWPROFILE
                echo "VMDISK${VMDISKCNT}MNTP=${UVMDISKMNTP}" >> $TMPHWPROFILE
                echo "VMDISK${VMDISKCNT}LVMVG=${UVMDISKLVMVG}" >> $TMPHWPROFILE
                echo "VMDISK${VMDISKCNT}LVMLV=${UVMDISKLVMLV}" >> $TMPHWPROFILE

                F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}TYPE=${UVMDISKTYPE}"
                F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}SIZEGB=${UVMDISKSIZEGB}"
                F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}OPTS=${UVMDISKOPTS}"
                F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}DEV=${UVMDISKDEV}"
                F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}FS=${UVMDISKFS}"
                F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}MNTP=${UVMDISKMNTP}"
                F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}LVMVG=${UVMDISKLVMVG}"
                F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}LVMLV=${UVMDISKLVMLV}"
 
                F_LOG $FUNCNAME "additional disk config needed. disks left: $(($VMDISK - $VMDISKCNT))"
            done
            VMERR=$?
        else
            F_LOG $FUNCNAME "No additional disk config needed or a prev error occured"
        fi

        if [ $VMERR -eq 0 ];then
            HSETOK=99
            while [ $HSETOK -ne 0 ];do
                grep "${VMHOST}.${VMSDOMAIN}" "$HOSTFILE" -q
                HSETOK=$?
                if [ $HSETOK -ne 0 ];then
                    F_DIALOG --msgbox "\nThe server is not in $HOSTFILE.\nIt must be added now before we can continue.\n\n${VMHOST}.${VMSDOMAIN}\n(mouse to select, ctrl+shift+C to copy)\n\nmust be added to $HOSTFILE before you can continue.\nWhen you press OK $EDITBIN will be used to open it." 16 100
                    $EDITBIN $HOSTFILE
                fi
            done
        
            # switch to vCenter information and actions
            VCENTER=$(F_VCGETINFO 2>&1 >/dev/tty)
            VMERR=$?
            F_DIAERR $VMERR "Deploying $VMHOST"
        fi
    done

    if [ $VMERR -eq 0 ];then
        F_SYSUPGRADE "${VMHOST}.${VMSDOMAIN}"
        F_DIAERR $? "Upgrading System"
    fi
    
    # close function when aborted
    [ $ABORTED -eq 1 ] && F_LOG $FUNCNAME "closing func due to abort state" && continue

    F_LOG $FUNCNAME ended
}

## @fn F_SYSUPGRADE()
## @brief system upgrade tasks
## @exception ..
## @details N/A
F_SYSUPGRADE(){ 
    F_LOG $FUNCNAME started
    GHOST="$1"
    unset AUTOMODE PARENTPID
    export PARENTPID=$BASHPID
    AUTOMODE="$1"

    if [ -z "$AUTOMODE" ];then
        SELHOSTS="$(F_SELHOST)"
        [ "$SELHOSTS" == ABORTED ] && return 4
            CREDS=$(F_GETAPICREDS)
            SPLUSR="${CREDS/:*}"
            SPLPW="${CREDS/*:}"
    else
        SELHOSTS="$AUTOMODE"
    fi

    F_LOG $FUNCNAME "selected hosts for upgrade: $SELHOSTS"

    [ -z "$SELHOSTS" ] && F_DIAERR 9 "missing param for $FUNCNAME" && break 99

    for uhost in $(echo "$SELHOSTS" |tr " " "\n" | cut -d ":" -f 1);do
        # check ssh first
        F_CHECKSSH "$uhost"
        F_A2BIN $HOSTFILE $PBSYSYUM "Upgrading $uhost ..." "--limit $uhost" || break
    done
    F_DIAERR $? "System Upgrade(s) on:\n$SELHOSTS\n\nA REBOOT IS REQUIRED!"
    
    F_LOG $FUNCNAME ended
}

## @fn F_CHECKSSH()
## @brief system upgrade tasks
## @param 1 required: the host from the inventory to be checked
## @param 2 optional: the full path to another hostfile
## @details tbd
F_CHECKSSH(){ 
    F_LOG $FUNCNAME started

    CHOST="$1"
    DHOSTF="$2"

    [ -z "$CHOST" ] && F_DIAERR 9 "missing arg in $FUNCNAME" && break 99
    [ -z "$DHOSTF" ] && DHOSTF="$HOSTFILE"

    F_A2BIN $HOSTFILE $PBSSHCHK "checking $CHOST ..." "--limit $CHOST"

    F_LOG $FUNCNAME ended
}

# the main menu window in regular mode
F_MENUMAIN(){
    F_HOSTFILE
	MENUDONE=0
 	    while [ "$MENUDONE" == "0" ]; do
		SELECTION=$(F_DIALOG --ok-label "Select Entry" --cancel-label "Exit" --colors \
			--menu "\nSelect an option:" \
			35 76 35 \
			'' '\Zb\ZuAPPS\ZB\ZU'\
			"" "" \
			Link-app "Link an app (local file or git project) to a group" \
			Deploy-apps "Deploy linked apps for a target group" \
			Remove-app "Unlink or completely remove an app of a group" \
			Show-apps "Show all already linked apps" \
			"" "" \
			'' '\Zb\Zusystem/local/*.conf\ZB\ZU'\
			"" "" \
			Edit-SYSC "Fetch/Edit/Show/Manage remote conf files" \
			Deploy-SYSC "Deploy enabled system configs"\
			"" "" \
			'' '\Zb\Zusplunk> Tasks\ZB\ZU' \
			"" "" \
			shelper	"Upgrade/Install/Use the shelper" \
			Stop/Start "stop, start, restart splunk>" \
			"" "" \
			'' '\Zb\Zusplunk> Maintenance\ZB\ZU' \
			"" "" \
			Upgrade	"Opens a submenu with upgrade tasks" \
			VM-Deploy "Deploy a new blank VM (OS + ansible-ready)" \
			Install	"splunk> on ansible-ready server(s)" \
                        Configure "Configure splunk> on fresh installed splunk instances" \
			Cluster "Indexer tasks" \
			"" "" \
			"" "" \
			3>&1 1>&2 2>&3)

			#UpgradeCluster "Upgrade a splunk> cluster (SH / IX)" \

		if [ "$?" != "0" ]; then
		    MENUDONE=1
		    echo "$0: finished."
		    F_EXIT
		fi
		case "$SELECTION" in
			New-app)
			;;
			Link-app)
			F_ENAPP
			;;
			Deploy-apps)
			F_DEPLOYMENU
			;;
			Remove-app)
			F_RMAPP
			;;
			Show-apps)
			SELECTION=$(F_SELECTOR)
			F_GOAPPS
			;;
			Edit-SYSC)
			F_EDITSYSC
			;;
			Pull-SYSC)
			F_PULLSYSC
			;;
			Deploy-SYSC)
			#SELECTION=$(F_SELECTOR)
			F_DEPLSYSC "$(F_SELECTOR)"
			;;
			Upgrade)
			F_UPGRADEMENU
			;;
			Stop/Start)
			F_SPLACT
			;;
			shelper)
			F_SHELPER
                        F_ABORTMAINMENU F_SHELPER
			;;
			gitlab)
			F_SETUP_GITLAB
			;;
			Install)
			F_INSTALLSPL
			;;
			Cluster)
			F_CLUSTER
			;;
                        VM-Deploy)
                        F_DEPLOYVM
                        ;;
                        Configure)
                        F_CONFMENU
                        ;;
		esac
	     done
}

# the main menu window in testing mode
F_MENUTESTING(){
    F_HOSTFILE
    MENUDONE=0
    [ "$ENABLEVAULT" == "yes" ] && [ ! -s $VAULTTEMPFILE ] && [ "$ENABLEVAULT" == "yes" ] && F_VAULTPW
	    while [ "$MENUDONE" == "0" ]; do
		SELECTION=$(F_DIALOG --colors --ok-label "Select Entry" --cancel-label "Exit" \
			--menu "\nStart the ansible engine\n\n\Zb\Z1TESTING AREA - TESTING AREA - TESTING AREA\Zn\n\nSelect an option:" \
			25 76 25 \
			"" "" \
			3>&1 1>&2 2>&3)
		if [ "$?" != "0" ]; then
		    MENUDONE=1
		    echo "$0: finished."
		    F_EXIT
		fi
		case "$SELECTION" in
			Disable-app)
			;;
		esac
	     done

}

# the main menu window in advanced mode
F_MENUADVANCED(){
	while [ "$MENUDONE" == "0" ]; do
                SELECTION=$(F_DIALOG --colors --ok-label "Select Entry" --cancel-label "Exit" \
                        --menu "\nStart the ansible engine\n\n\Zb\Z1ADVANCED AREA - ADVANCED AREA - ADVANCED AREA\Zn\n\nSelect an option:" \
                        20 76 20 \
                        ______________ "ADVANCED (no daily business)  ______________" \
                        "" "" \
                        Pull-SYSC "Fetch config for a target (if Edit-SYSC fails)"\
                        gitlab  "(Re-)Initialize gitlab server authentication"\
                        3>&1 1>&2 2>&3)
                if [ "$?" != "0" ]; then
                    MENUDONE=1
                    echo "$0: finished."
		    F_EXIT
                fi
                case "$SELECTION" in
                        Pull-SYSC)
                        F_PULLSYSC
                        ;;
                        gitlab)
                        F_SETUP_GITLAB
                        ;;
                esac
	done	
}

# ugly but efficient
echo "$@" |grep -q "\-help"
[ $? -eq 0 ]&& F_HELP && F_EXITUNCLEAN

# ensure we know the real user and deny starting AE directly as SPLUSER
ME=$(id -un)
[ "$ME" == "$AEUSER" -a -z "$CALLUSR" ] && echo -e "\n\nERROR: Starting AE as user $AEUSER has been denied.\nAE must be started as your REAL user since v2.3!\n\nSo .. logout as user splunk and try again with your regular user\n\n" && F_EXIT
if [ "$ME" != "$AEUSER" ] || [ -z "$CALLUSR" ];then
    echo "Thanks for choosing AE $ME, starting AE now ($@) ..."
    sudo -u $AEUSER /usr/bin/env CALLUSR=$ME $0 $@ 
    F_EXITUNCLEAN
fi

echo "starting the engine as user $ME"

# pre-check Ansible reqs
# check ansible version first
unset AVERSF AVERS A2VERSF A2VERS
MREQAVERSION=$(echo $REQAVERSION |tr -d ".")
AVERSF=$($ABIN --version |head -n 1 | egrep -o "[1-9]\.[0-9]\.[0-9]")
AVERS=$(echo $AVERSF | tr -d ".")
[ -f "$A2BIN" ] && A2VERSF=$(F_A2BIN version |head -n 1 | egrep -o "[1-9]\.[0-9]\.[0-9]") && A2VERS=$(echo $A2VERSF | tr -d ".")
F_LOG MAIN "Detected Ansible version(s):\nAVERS: $AVERS\nA2VERS: $A2VERS\nMin required: $MREQAVERSION"

if [ -z "$A2VERS" ];then
   [ "$AVERS" -lt "$MREQAVERSION" ] && F_DIAERR 999 "No suitable Ansible version found!!!\nRequired: $REQAVERSION\nFound: $AVERSF" && F_EXIT
    export MAXAVERSION=$AVERSF
else
   [ "$A2VERS" -lt "$MREQAVERSION" ] && F_DIAERR 999 "No suitable Ansible version found!!!\nRequired: $REQAVERSION\nFound: $A2VERSF" && F_EXIT
    export MAXAVERSION=$A2VERSF
fi
 
echo "$@" |egrep -q "(noninteractive|batch)"
if [ $? -eq 0 ];then
   # enter batch mode
    export LOG=$WORKDIR/${BIN}_batchmode.log
    # detect running session and kill/ask
    [ -f $EXECBIT ] && echo -e "\n\nWARNING: It seems ansible-engine is already running by user: $(cat $EXECBIT)! ABORTED!" && F_LOG "$BIN" "ansible-engine is already running by $(cat $EXECBIT). ABORTED!" && exit 99

    echo "$CALLUSR" > $EXECBIT && chmod o+w $EXECBIT
    echo "Starting new log - $(date +%Y-%m-%d_%T)" > $LOG
    # reset any previous set user host file
    > $AEUSRHOSTFILE

   # parse args
   while [ ! -z "$1" ];do
     case "$1" in
	    -1) BABIN=$ABIN ;shift;;
        --batch|--noninteractive) shift;;
	    -p|--play) BPLAY="$2"; shift 2;;
        -a|--action) BACT="$2"; shift 2;;
	    -t|--target) BTARGET="$2"; shift 2;;
        -i|--inventory) export HOSTFILE="$2"; export SHOSTFILE="$HOSTFILE"; FORCEDHOSTFILE="$2"; shift 2;;
        --env) TARGETENV=$2; shift 2 ;;
        --deployapp)
        export BDEPAPP="$2"
        export BDEPAPPSUBSET=1
        shift 2
        ;;
	    *) echo -e "ERROR unknown argument: $1\n"; F_EXIT ;;
     esac
   done
   # validate args
   for f in $HOSTFILE $BPLAY; do
	if [ ! -f $f ];then
	  echo "ERROR missing file: >$f<"
	  F_EXIT
	fi
   done
   [ -z "$BTARGET" -o -z "$HOSTFILE" ] && echo -e "ERROR: missing a required arg\n(target:$BTARGET,hosts:$HOSTFILE)!" && F_EXIT 
   [ -z "$BACT" -a -z "$BPLAY" ] && echo -e "ERROR: Either action or play must be defined (action: $BACT, play: $BPLAY)!" && F_EXIT 
   # run
    export RUNMODE=batch
    if [ -z "$BACT" ];then
        echo "$BABIN -i $HOSTFILE $BPLAY -e \"target=$TARGET accept_hostkey=true\" --tags $TARGET"
    else
        case $BACT in
            deploy)
            DEPLOYAPPSUBSET=$BDEPAPPSUBSET F_DEPLOYAPP
            ;;
            *)
            echo "ERROR: Action $BACT does not exists!"
            exit 3
            ;;
        esac
    fi
else
    # interactive mode
    MENUDONE=0
    # detect running session and kill/ask
    [ -f "$EXECBIT" ] && echo -e "\n\nWARNING: It seems ansible-engine is already opened by >$(cat $EXECBIT)<?!\nIf you feel this is an error remove >$(cat $EXECBIT)< and start again. or..." && read -p "....do you want ME to override, delete the execbit and continue anyways (no risk no fun heh?)? (y/N)" KICKUSER
    echo KICK: $KICKUSER
    [ -f "$EXECBIT" ]&&[ "$KICKUSER" != "y" ] && F_EXITUNCLEAN
   
    echo "$CALLUSR" > $EXECBIT && chmod 777 $EXECBIT
    echo "Starting new log - $(date +%Y-%m-%d_%T)" > $LOG
    # reset any previously set user host file
    > $AEUSRHOSTFILE

    while [ ! -z "$1" ]; do
      case "$1" in
	--advanced)
	MAINMENU=F_MENUADVANCED
	shift
	;;
	--testing)
	MAINMENU=F_MENUTESTING
	shift
	;;
	--env)
	export TARGETENV=$2
	shift 2
	;;
    -i|--inventory)
    export FORCEDHOSTFILE="$2"
    shift 2
    ;;
	*)
	F_HELP
	F_EXIT
	;;
      esac
    done
    # support multiple environments
    while [ -z "$TARGETENV" ];do
	TARGETENV=$(F_CHOOSEENV)
        [ "$TARGETENV" == "ABORTED" ] && F_EXIT
    done

    [ ! -d "$AINVENTORY/$TARGETENV" ] && echo -e "\nERROR: specified environment $TARGETENV\n($AINVENTORY/$TARGETENV)\ndoes not exist!" && F_HELP && F_EXIT
    [ -z "$MAINMENU" ]&& MAINMENU=F_MENUMAIN
    $MAINMENU
fi

F_EXIT
