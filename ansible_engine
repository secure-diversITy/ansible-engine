#!/bin/bash
########################################################################################
## @file			ansible_engine.sh
## @brief			-THE- GUI for using ansible + splunk
## @author			Thomas Fischer <mail -AT- sedi -DOT- one>
## @date                        2017-2018
## @copyright			LGPL v3
## @details
##    This program is free software: you can redistribute it and/or modify<br>
##    it under the terms of the GNU General Public License as published by<br>
##    the Free Software Foundation, either version 3 of the License, or<br>
##    (at your option) any later version.<br>
##    <br>
##    This program is distributed in the hope that it will be useful,<br>
##    but WITHOUT ANY WARRANTY; without even the implied warranty of<br>
##    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<br>
##    GNU General Public License for more details.<br>
##    <br>
##    You should have received a copy of the GNU General Public License<br>
##    along with this program.  If not, see <http://www.gnu.org/licenses/>.
##
########################################################################################
#
## @mainpage ansible engine (ae)
## @section intro Overview
## ansible engine (ae) is a wrapper and GUI (ncurses/dialog based) to execute several tasks with ansible.<br>
## This is a pure **technical** documentation of ae for those who want to understand how ae works under the hood
##
## @section code Code
## ansible engine is hosted at github:<br>
## https://github.com/secure-diversITy/ansible_engine
## 
## @section secintro User documentation
## The ansible engine (ae) configuration and installation is described here: <br>
## https://github.com/secure-diversITy/ansible_engine/wiki
##<br>
###############################################################################################################
VERSION=20180420
###############################################################################################################
#
# doxygen copy templates:
#
# # @var 
# # @brief 
# # @showinitializer
# # @details 
#
# # @fn F_NAME()
# # @brief ..
# # @param 1 ..
# # @return ..
# # @exception ..
# # @details ..
##############################################################################################################


## @var PYTHONUNBUFFERED
## @brief avoid buffering when exec python code (ansible)
## @showinitializer
## @details when python buffers output ae seems to hang until the 
## whole playbook has been finished without any feedback. This ensures we see output directly in ae.
export PYTHONUNBUFFERED=1

## @var BIN
## @brief auto generate the binary name without path
## @showinitializer
declare BIN=${0##*/}

## @var WORKDIR
## @brief The working directory where all run files of ae will be stored
## @showinitializer
declare WORKDIR=".$(echo ${BIN/.sh}|tr -d _)"
[ ! -d "$WORKDIR" ]&& mkdir -p $WORKDIR

# we resist on the bashrc alias so using pwd is fine here
ADIR=${PWD}

# the path where your inventories (with their subdirs like development, production) are in
AINVENTORY=$ADIR/inventories

# normally we want to have 1 instance running the same time. This avoids dozens of problems which could occur.
KICKUSER=N

EXECBIT=$WORKDIR/.inuse
[ -f $EXECBIT ]&& echo -e "\n\nWARNING: It seems ansible-engine is already opened?!\nIf you feel this is an error remove >$EXECBIT< and start again. or..." && read -p "....do you want ME to override, delete the execbit and continue anyways (no risk no fun heh?)? (y/N)" KICKUSER

[ -f $EXECBIT ]&&[ "$KICKUSER" != "y" ] && exit

> $EXECBIT

ABIN=ansible-playbook

# if you want you can run another ansible version by specifying the A2xx vars:
A2PATH=/opt/splunk/ansible-git
A2BIN=$A2PATH/bin/ansible-playbook

## @var LOG
## @brief The ae log file
## @showinitializer
declare LOG=$WORKDIR/${BIN}.log

## @var AEINFOHOSTFILE
## @brief the user choosen hostfile will be written into this file
## @details can be sourced like: source $AEUSRHOSTFILE - will set HOSTFILE=
## @showinitializer
declare AEUSRHOSTFILE=${WORKDIR}/ae_current_hostfile

# reset any previous set user host file
> $AEUSRHOSTFILE

## @var EDITBIN
## @brief The editor which will be used e.g. when editing system/local files
## @showinitializer
declare EDITBIN=/usr/bin/vim

## @var PBDIR
## @brief The directory where all playbooks are expected
## @showinitializer
declare PBDIR="$PWD"

## @var PBNEWAPP
## @brief Adding/Linking new app(s) to ae
## @showinitializer
declare PBNEWAPP=add_app.yml
## @var PBENAPP
## @brief Adding/Linking new app(s) to ae (the real action)
## @showinitializer
declare PBENAPP=enable_app_action.yml
## @var PBDEPLAPP
## @brief Deploy apps to given targets
## @showinitializer
declare PBDEPLAPP=ae_deploy_apps.yml
## @var PBDEPLSYSC
## @brief Deploy system/local configs to given targets 
## @showinitializer
declare PBDEPLSYSC=deploy_systemconfigs.yml
## @var PBGETTARGETS
## @brief Parsing inventories file and create an expanded host list for each target
## @showinitializer
declare PBGETTARGETS=ae_get_targets.yml
## @var PBUPGRADE
## @brief Upgrade splunk
## @showinitializer
declare PBUPGRADE=upgrade_splunk.yml
## @var  PBSHINSTALL
## @brief Install/Upgrade the splunk helper
## @details https://github.com/secure-diversITy/splunk/tree/master/splunkhelper
## @showinitializer
declare PBSHINSTALL=install_shelper.yml
## @var SHOWAPPS
## @brief Show app deployment state by target(s) and type (local, git, ...)
## @showinitializer
declare SHOWAPPS=show_app_deploymentstate.sh
## @var PBSHRELOAD
## @brief Execute splunk helper tasks
## @details https://github.com/secure-diversITy/splunk/tree/master/splunkhelper
## @showinitializer
declare PBSHRELOAD=${ADIR}/maintenance/shelper_reload.yml
## @var PBSPLACT
## @brief Maintenance tasks for splunk
## @details Examples: splunk stop, start, restart
## @showinitializer
declare PBSPLACT=${ADIR}/maintenance/splunk_tasks.yml
## @var PBINSTALL
## @brief Install splunk
## @details Will install splunk on a single host or group of hosts
## @showinitializer
declare PBINSTALL=install_splunk.yml
## @var PBCONFPEER
## @brief Configures splunk as a peernode 
## @details This will configure an existing splunk installation as a peernode of an existing indexer cluster
## @showinitializer
declare PBCONFPEER=${ADIR}/ae_configure_ix_peernode.yml

# default splunk API admin
DEFSPLAPIADMIN=admin

# default filename where your hosts defined. can be changed interactive
DEFHOSTFILE=hosts

# gitlab authentication file
GLABSETTINGS=$WORKDIR/gitlab.auth

#################################################################################################
# NO CHANGES BEHIND THIS POINT
#################################################################################################

## @fn F_ENDSESS()
## @brief Clear ae session
## @details ae ensures it will not be executed more then 1 time by the EXECBIT var
F_ENDSESS(){
	echo "$FUNCNAME started" >> $LOG
	rm -vf $EXECBIT >> $LOG
	echo "$FUNCNAME finished" >> $LOG
}

## @fn F_EXIT()
## @brief The regular exit
## @param 1 when set to 'NOSESSEXIT' no session exit will happen (rare)
## @return 0
## @details If just executed without param ae will not clear the session
## but when a full abort is required use param 1 accordingly
F_EXIT(){
	echo "$FUNCNAME started" >> $LOG
	
	if [ "$1" == "NOSESSEXIT" ];then
		echo "$FUNCNAME: No session exit" >> $LOG
	else
		# clear the execbit
		F_ENDSESS
		echo "$FUNCNAME finished" >> $LOG
	fi
	# finally terminate
	exit 0
}

# catch ctrl+c !! to terminate cleanly..
trap F_EXIT SIGINT

# check requirements first
dialog --version >> /dev/null 2>&1
if [ $? -ne 0 ];then
	echo -e "\nplease install the software <dialog> first!\n"
else
    $ABIN --version >> /dev/null 2>&1
    if [ $? -ne 0 ];then
        echo -e "\nReally?? You want to use ansible deployment without ansible??! Coooool.. Install ansible and try again..\n"
	F_EXIT
    fi
    for i in $(echo $SHOWAPPS $PBNEWAPP $PBENAPP $PBDEPLSYSC);do
	if [ ! -r $i ];then 
	    echo -e "\n\tERROR. Please ensure you've done chmod +r $i first and that $i exists!\n"
	    F_EXIT
	fi
    done
fi

echo "Starting new log - $(date +%Y-%m-%d_%T)" >$LOG

# function to start A2BIN takes all args without any proof / verification!
# TODO: parse args and do a basic validation?!
F_A2BIN(){
	# returns error code of the playbook run
	#
	# requires these parameters:
	A2HOSTFILE="$1" # the ansible hostfile
	A2PB="$2"	# the ansible playbook
	BOXTITLE="$3"	# the title for the progressbox of the playbook run

	# optional:
	# ansible extra args. space separated parameters like -e 'var1=moo var2=cow' need to be defined in JSON format!!
	# e.g.: F_A2BIN hosts myplaybook myboxtitle "-e {'var1':'moo','var2':'cow'}"
	A2ARGSRAW="$4"	

	F_LOG $FUNCNAME started
	F_LOG $FUNCNAME "ARGSRAW: $A2ARGSRAW"
	
	# find space keyword
	A2ARGS=$(echo "$A2ARGSRAW" | sed 's/SPACE/ /g')
	F_LOG $FUNCNAME "ARGS: $A2ARGS"
	
	if [ -z "$A2HOSTFILE" ]||[ -z "$A2PB" ]||[ ! -f "$A2HOSTFILE" ]||[ ! -f "$A2PB" ];then
		F_DIAERR 3 "INTERNAL ERROR: Missing or wrong ARGS for $FUNCNAME!"
		F_EXIT
	fi

	F_LOG $FUNCNAME "$A2BIN -i $A2HOSTFILE ${A2ARGS} $A2PB"
	F_LOG $FUNCNAME "python path before: $PYTHONPATH"
	export PYTHONPATH=${A2PATH}/lib
	F_LOG $FUNCNAME "python path after: $PYTHONPATH"
	$A2BIN -i $A2HOSTFILE $A2PB ${A2ARGS} 2>&1 | tee -a $LOG | sed -u -r 's/(.*DEPRECATION.*)//Ig' | F_DIALOG --scrollbar --colors --progressbox "$BOXTITLE" 1000 1000
	A2ERR="${PIPESTATUS[0]}"
	F_LOG $FUNCNAME finished
	return $A2ERR
}

# logging in a specific format
F_LOG(){
	# takes 2 args:
	#  $1 = the calling function
	#  $2 = the message to be logged

	CALLER="$1"
	MSG="$2"
	if [ -z "$MSG" ]||[ -z "$CALLER" ];then
		F_DIAERR 2 "INTERNAL ERROR: $FUNCNAME requires an arg"
	else
		PREFIX="$(date '+%F_%T') ($CALLER) -"
		echo -e "$PREFIX $MSG" >> $LOG
	fi
}

# main dialog form
F_DIALOG(){
	dialog --title "ae for splunk> (v$VERSION)" "$@"
}

# really? you want to read a comment for this function?
F_HELP(){
	echo
	echo -e "    USAGE/HELP for $BIN"
	echo
	echo -e "    Mandatory:\n    ---------------------"
	echo -e "\t--env [production | development | ...]"
	echo -e "\t\t\tdefine the running environment ($ADIR/inventories/[your --env setting]/"
	echo -e "\n    Optional:\n    ---------------------"
	echo -e "\t--help\t\tWill show this\n"
	echo -e "\t--advanced\tWill enable/show advanced option menu"
	echo -e "\t--testing\tUnfinished menu options"

	echo -e "\n\t--batch|--api\t\tUNFINISHED! Enables full automated way of using ansible-engine"
	echo -e "\t  Batch options:"
	echo -e "\t  -1 (will use ansible v1)  | -2 (will use ansible v2)"
	echo -e "\t  -p|--play <playbookname>"
	echo -e "\t  -t|--target <targetgroup>"
	echo -e "\t  -i|--inventory <hosts filename>"
	echo
}

# show app deployment state
F_SHOWAPPS(){
	echo "$FUNCNAME started" >> $LOG
	SEL="$1"
	[ -z "$SEL" ]&& echo ERROR missing arg for F_SHOWAPPS
	if [ "$SEL" == "ALL" ];then
		./$SHOWAPPS -env $AINVENTORY/$TARGETENV
	else
		./$SHOWAPPS -env $AINVENTORY/$TARGETENV "$SEL"
	fi
	echo "************************************************"
	read -p "To continue press ENTER" DUMMY
	echo "$FUNCNAME finished" >> $LOG
}

# do you wanna see all or choose
F_SELECTOR(){
	echo "$FUNCNAME started" >> $LOG
	SELECTION=$(F_DIALOG --menu "\nChoose an option:" \
			15 76 14 \
			Choose "" \
			ALL "" \
			3>&1 1>&2 2>&3)
	echo "$SELECTION"
	echo "$FUNCNAME finished" >> $LOG
}

# show current apps deployment
F_GOAPPS(){
	echo "$FUNCNAME started" >> $LOG
	if [ "$SELECTION" == "ALL" ];then
		F_SHOWAPPS "ALL"
	else
		if [ "$SELECTION" == "Choose" ];then
			OPTIONS=($(for i in $(find $AINVENTORY/$TARGETENV/group_vars/* -maxdepth 1 -type d |egrep -v "(templates|all)" |sed s#$AINVENTORY/$TARGETENV/group_vars/##g);do echo $i $i off;done))
			SELECTION=$(F_DIALOG --checklist "Select options:" 22 76 16 "${OPTIONS[@]}" 2>&1 >/dev/tty)
			if [ -z "$SELECTION" ];then
			F_DIALOG --msgbox "ERROR: no selection made. Choose 1 or more targets with space bar." 10 30 
			else
				F_SHOWAPPS "$SELECTION"
			fi
		else
			echo ERROR no selection made 
		fi
	fi
	echo "$FUNCNAME finished" >> $LOG
}

# ask for hosts filename (will list all hosts* files as well)
# returns either the hostfile or ABORTED if the user cancels
F_HOSTFILE(){
	echo "$FUNCNAME started" >> $LOG
	STARTOVER=1
	ABORT=0
	while [ $STARTOVER -eq 1 ];do
		unset OPTIONS SELECTION HOSTFILE
		# detect available host files
		while [ -z "$SHOSTFILE" ];do
			OPTIONS=($(for i in $(find $AINVENTORY/$TARGETENV -maxdepth 1 -type f -name "hosts*" |grep -v template);do echo ${i##*/} file;done))
			SHOSTFILE=$(F_DIALOG --menu "Select a hosts file:" 22 76 16 "${OPTIONS[@]}" manually "type in a path" 2>&1 >/dev/tty)
			[ $? -ne 0 ] && HOSTFILE="ABORTED" && F_ABORTMAINMENU 
		done
		if [ "$SHOSTFILE" == "manually" ];then
			SHOSTFILE=$(F_DIALOG --inputbox 'Type in your hosts filename' 20 100 $DEFHOSTFILE 2>&1 >/dev/tty)
		fi
		# construct the full host filename
		HOSTFILE="${AINVENTORY}/${TARGETENV}/${SHOSTFILE}"
		if [ ! -r "$HOSTFILE" ];then
			F_DIALOG --msgbox "\n\nERROR: $HOSTFILE does not exist or is not readable" 10 80
			STARTOVER=1
		else
			STARTOVER=0
		fi
	done
	echo "HOSTFILE=\"$HOSTFILE\"" > $AEUSRHOSTFILE
	F_LOG $FUNCNAME "written new AEUSRHOSTFILE ($AEUSRHOSTFILE):\n$(cat $AEUSRHOSTFILE)"
	F_LOG $FUNCNAME finished
}

## @fn F_TARGETS()
## @brief identify targets/hosts of a group
## @param 1 required: dialog option (checklist/radiolist)
## @param 2 optional: automatic/non interactive mode (auto selected group name|empty)
## @return list of hosts
## @exception on error or abort: abort
## @details 
## 1. filter out all vars and child sections
## 2. get all sections and 1 next line
## 3. replace [ with newline
## 4. replace ] with comma and empty lines with a /
## 5. remove all newlines
## 6. replace // with /
## 7. replace / with newline
## --> steps 4-7 are required to ensure even when 2 sections are written without a space
##     between. Example:
##	[sec1]
##  	[sec2]
##  	host
##     As we catch always section + 1 next line on step 2 to identify empty sections the above 
##     steps ensure we will *NOT* have a result of: "sec1" has host "sec2"
## 8. get only these lines containing a comma and something behind (means section has a value)
##    this is needed as a section can be empty which shouldnt be shown if!
F_TARGETS(){
	F_LOG "$FUNCNAME" "started with these arguments: $@"
	
	OPTIONS=($(for i in $(egrep -v "(:vars|:children)" "$HOSTFILE" | egrep --group-separator="/" -A1 "^\[.*\]"| tr "[" "\n" |sed -e 's/\]$/,/g;s/^$/\//g'| tr -d "\n" | sed 's#//#/#g' | tr "/" "\n" | egrep ",\w+" | cut -d "," -f1);do echo $i $i off; done))
	# OPTIONS EXPLANATION ABOVE

	if [ -z "$1" ];then 
		echo -e "\n\nERROR! Missing F_TARGETS arg!! Cannot continue...\n" && F_EXIT
	else
		DOPT="$1"
	fi
	unset NIGRP
	NIGRP="$2"
	if [ -z "$NIGRP" ];then
	        HOSTSELECTION=$(F_DIALOG --${DOPT} "Please use the space-bar to make your selection:" 30 80 30 "${OPTIONS[@]}" 2>&1 >/dev/tty)
		HERR=$?
		F_LOG "$FUNCNAME" "HERR was $HERR"
		if [ "$HERR" != "0" ];then
			echo "ABORTED"
		else
			echo "$HOSTSELECTION"
		fi
	else
		echo "${OPTIONS[@]} | cut -d ' ' -f 1 |grep $NIGRP"
	fi
	F_LOG "$FUNCNAME" "finished"
}

# group_vars dir check and initiate if needed
F_GVARDIR(){
	echo "$FUNCNAME started" >> $LOG
	INIT=0
	TG=$1
	TDIR=$AINVENTORY/$TARGETENV/group_vars/$TG
	[ -z "$TG" ]&& echo "Missing arg for $FUNCNAME!! ABORTED" && F_EXIT
	if [ -d "$TDIR" ];then
		echo "$TDIR" exists >> $LOG
		if [ -f "$TDIR/deployment" ];then 
			echo already initialized >> $LOG
		else
			INIT=1
		fi
	else
		INIT=1
	fi
	if [ "$INIT" -eq 1 ];then
		echo creating $TDIR >>$LOG
		mkdir $TDIR >>/dev/null 2>&1
		ERRC=0
		while [ -z "$DEPL" ]&&[ "$ERRC" -eq 0 ];do
			DEPL=$(F_DIALOG --inputbox "Initializing of <$TDIR> required\nPlease type in where you want to deploy apps for >$TG<.\n\nJust type <apps>, <deployment-apps>,<shcluster/apps>, etc and not the full path:" 15 100 2>&1 >/dev/tty)
			ERRC=$?
		done
		if [ $ERRC -eq 0 ];then
			echo "will create deployment file with: $DEPL as target dir" >> $LOG
			# creating deployment file:
			cat >> $TDIR/deployment <<EOF_DEPL
---
#####################################################################################################################
# Configurations for Splunk deployment directory
# Keep in mind to replace "-" and "/" with an underscore "_"
#####################################################################################################################

deployment:
    dir: $DEPL
EOF_DEPL
		fi
	fi
	echo "$FUNCNAME finished" >> $LOG
}

# deploy system/local configs
F_DEPLSYSC(){
	echo "$FUNCNAME started" >> $LOG
	F_HOSTFILE
	SELECTION="$1"
	if [ "$SELECTION" == "Choose" ];then
	     unset HOSTSELECT HOSTSELECTION
	     while [ -z "$HOSTSELECT" ];do
		HOSTSELECTION=$(F_TARGETS checklist)
		[ $HOSTSELECTION == "ABORTED" ] && ABORTED=1 && break
	         if [ -z "$HOSTSELECTION" ];then
                     F_DIALOG --msgbox "ERROR: no selection made. Choose 1 or more targets with space bar." 10 30 
                 else
                     HOSTSELECT=1
		     ABORTED=0
                 fi
	     done
	     if [ "$ABORTED" -ne 0 ];then
                echo "DEBUG: aborted by user."
	     else
		  F_DIALOG --yesno "\nAre you sure you want to continue?\n\nThis will deploy the system/local configs to:\n\n$HOSTSELECTION" 15 80
		  if [ $? -eq 1 ];then
			ABORTED=1 
		  else
		     # TODO: optimize playbook exec to just exec on group instead of for each host
			unset HOSTSELEXPANDED
			HOSTSELEXPANDED=$(F_EXPANDHOSTS "$HOSTSELECTION" | grep -v EMPTY |cut -d : -f 1)
			# host 1,2,3,... of shcmember
			for hex in $HOSTSELEXPANDED;do
			     echo "processing host >$hex<" >>$LOG
			     for hgroup in $HOSTSELECTION;do
				echo "processing $hex in >$hgroup<" >>$LOG
				# for shcmember, ...
				#F_GVARDIR "$hgroup"
				# update task etc stuff first
				F_TPLUPDATE "roles/system" "$hgroup/$hex"
				echo -e "Will play:\n$ABIN -i $HOSTFILE $PBDEPLSYSC -e \"target=$hgroup exp_host=$hex\"" >> $LOG
				$ABIN -i $HOSTFILE $PBDEPLSYSC -e "target=$hgroup exp_host=$hex"
				ERR=$?
				F_DIAERR "$ERR" "on \Zb\Z1<$hex>\Zn"
				[ $ERR -ne 0 ]&& F_MSG "ERROR: ABORTED deployment!" && break 2 >>$LOG
			done
		     done
		  fi
	     fi
	else
		F_DIALOG --msgbox "ERROR: Deploying to ALL is not supported yet" 10 100
	fi
	echo "$FUNCNAME finished" >> $LOG
}

# let the user choose to either catch existing conf from another host or locally
F_SSHORNOT(){
	echo "$FUNCNAME started" >> $LOG
	unset ANS
	while [ -z "$ANS" ];do
		#ANS=$(F_DIALOG --radiolist "\nDo you want to active pull the current config or use a local copy instead?\n(use the space-bar to select)" 15 80 3 Pull "Pull existing conf from a host (copy by SCP)" on Local "Choose a local dir for importing conf" off Skip "Use the local copy (POTENTIAL DANGEROUS. Will overwrite remote changes if any)" off 2>&1 >/dev/tty)
		ANS=$(F_DIALOG --radiolist "\nDo you want to active pull the current config or use a local copy instead?\n(use the space-bar to select)" 15 100 5 Pull "(RECOMMENDED) Pull current active conf" on ---- "--------------------------------------" off DANGEROUS-Import "OVERWRITES REMOTE! Import configs from a LOCAL directory" off DANGEROUS-Skip "OVERWRITES REMOTE! Just use the LOCAL(!!) existing files" off 2>&1 >/dev/tty)
		ERR=$?
		echo "$FUNCNAME: err was $ERR" >> $LOG
		if [ $ERR -ne 0 ];then
			echo "$FUNCNAME: err was $ERR" >> $LOG
			ANS="ABORTED"
		fi
		# reset ans when the user has selected the hint text...
		[ "$ANS" == "----" ]&&unset ANS
	done
	echo "$FUNCNAME finished" >> $LOG
	echo $ANS
}

# import by ssh from an existing host
F_DIMPORT(){
	echo "$FUNCNAME started" >> $LOG
	SSHHOST="$1"
	SSHPATH="$2"
	LOCTMP="$3"
	[ -d $LOCTMP ]&& rm -R $LOCTMP
	mkdir $LOCTMP
	scp ${SSHHOST}:${SSHPATH}/*.conf $LOCTMP/

	# return errorcode to calling function
	echo $?

#	SIMP=$(F_DIALOG --inputbox "$TPLMSG\nNow initialize the deployment directory by copying your initial config files you want to deploy.\n\n\nWhere should I copy the initial configs from:" 15 80 2>&1 >/dev/tty)
	echo "$FUNCNAME finished" >> $LOG
}

# file browser
F_DBROWSE(){
	echo "$FUNCNAME started" >> $LOG
	unset SDIR
        SDIR=$(F_DIALOG --colors --inputbox "\nSource path (full path) where to copy the initial configs from\n(on host \Zb\Z1<$1>\Zn):" 15 80 $2 2>&1 >/dev/tty)
	if [ $? -ne 0 ];then
            SDIR=999
        fi
	echo $SDIR
	echo "$FUNCNAME finished" >> $LOG
}

# define local repo dir + filename
F_LOCSRC(){
	echo "$FUNCNAME started" >> $LOG
	unset SDIR OPTIONS
	[ ! -d "$REPODIR" ]&& echo "Cannot determine repo dir <$REPODIR>!! ABORTED" && F_EXIT

	OPTIONS=($(for tgz in $(find $REPODIR -type f |grep -v "/splunk/"|egrep "(tar|tgz|spl)");do echo ${tgz##*/} "file" off; done))
	SDIR=$(F_DIALOG --checklist "Please use the space-bar to make your selection:" 22 80 16 "${OPTIONS[@]}" 2>&1 >/dev/tty)
        if [ $? -ne 0 ];then
            SDIR=999
        fi
        echo "$SDIR"
	echo "$FUNCNAME finished" >> $LOG
}

# expands a target group to a list of hostnames/ips defined in the users host file
# returns a space delimited list with the expanded list of hostnames
F_EXPANDHOSTS(){
	F_LOG "$FUNCNAME" "started with these arguments: $@"
	unset RET
	TGROUP=$1
	TGFILE="$WORKDIR/expanded_${SHOSTFILE}_${TGROUP}"
	if [ -z "$HOSTSELECTION" ];then
		F_HOSTFILE
	fi
	# get all hosts via playbook (will expand groups in groups etc)
	$ABIN -i $HOSTFILE $PBGETTARGETS -e "target=$TGROUP expandfile=$TGFILE" |sort 2>&1>> $LOG

	# parse the resulted FILE and massage its content
        if [ -r "$TGFILE" ];then
              # filter ansible stuff:
	      RET=$(sed "s/,//g;s/\[//g;s/]//g;s/'//g" $TGFILE)
        else
	      # bark no error to the calling function but an error message in log
              F_LOG $FUNCNAME "WARNING: cant read/find $TGFILE! Empty group??"
	      RET="EMPTY"
        fi
	echo "$RET"
	F_LOG "$FUNCNAME" finished
}

# validate a dir if it contains conf files
F_VALCONF(){
	echo "$FUNCNAME started" >> $LOG
	find $1 -type f |grep -q "\.conf"
	if [ $? -ne 0 ];then
		F_DIALOG --msgbox "ERROR:\n\nThe path >$1< contains no single conf file!" 10 50
	fi
	echo "$FUNCNAME finished" >> $LOG
}

# delete empty conf files
F_CLEANCONF(){
	echo "$FUNCNAME started" >> $LOG
	CDIR=$1
	for cfile in $(find $CDIR -type f -name *.conf);do
		[ ! -s "$cfile" ]&& echo "$cfile is empty! Will remove it" >> $LOG && rm -v "$cfile" >> $LOG
	done
	echo "$FUNCNAME finished" >> $LOG
}

# dialog box providing errorcde
F_DIAERR(){
	echo "$FUNCNAME started" >> $LOG
	ERRC="$1"
	TASK="$2"

	[ -z "$ERRC" ]&&echo ERRORCODE MISSING for $FUNCNAME && F_EXIT

	if [ "$ERRC" != "0" ];then
		F_DIALOG --colors --msgbox "ERROR:\n\nTask $TASK ended with errorcode >$ERRC<!" 50 100
		# TODO: option to abort completely?
	else
		F_DIALOG --colors --msgbox "SUCCESS:\n\nTask $TASK ended successfully" 10 50
	fi
	echo "$FUNCNAME finished" >> $LOG
}

# dialog box very similar to F_DIAERR but givin an option to display a given logfile
F_ERRLOG(){
        echo "$FUNCNAME started" >> $LOG
        ERRC="$1"
        TASK="$2"
	DLOG="$3"

        [ -z "$ERRC" ]&&echo ERRORCODE MISSING for $FUNCNAME && F_EXIT

        if [ "$ERRC" != "0" ];then
                F_DIALOG --colors --extra-button --extra-label "Inspect" --msgbox "ERROR:\n\nTask ${TASK}\nended with errorcode >$ERRC<!" 40 100
                # TODO: option to abort completely?
		exit_status=$?
        else
                F_DIALOG --colors --extra-button --extra-label "Inspect" --msgbox "SUCCESS:\n\nTask ${TASK}\nended successfully" 40 100
		exit_status=$?
        fi
	if [ $exit_status -eq 3 ]; then
		F_DIALOG --colors --textbox "$DLOG" 50 200
	fi
        echo "$FUNCNAME finished" >> $LOG

}

# display a wait box
F_WAITBOX(){
	# requires 1 arg (message to show)
	MSG="$1"
	F_DIALOG --begin 3 3 --infobox "\n$MSG" 5 80
}

# enable an app for a host/target
F_ENAPP(){
	echo "$FUNCNAME started" >> $LOG
	unset HOSTFILE
	F_HOSTFILE
	unset HOSTSELEXPANDED ABORTED HTARGETS HOSTSELECT OPTIONS

	# local repository definition configuration file for tgz's	
	REPODEF=$AINVENTORY/$TARGETENV/group_vars/all/splunk_repository

	# extract repo dir for apps
	REPODIR="$(grep repository_root $REPODEF|cut -d ":" -f 2|tr -d " ")/apps"

        while [ -z "$HOSTSELECT" ];do
                HOSTSELECTION=$(F_TARGETS radiolist)
		[ $HOSTSELECTION == "ABORTED" ] && ABORTED=1 && break
                 if [ -z "$HOSTSELECTION" ];then
                     F_DIALOG --msgbox "ERROR: no selection made. Choose 1 or more targets with space bar." 10 30
                 else
                     HOSTSELECT=1
                     ABORTED=0
                 fi
        done
        if [ "$ABORTED" -ne 0 ];then
                echo "DEBUG: aborted by user."
        else
		#HOSTSELEXPANDED="$(F_EXPANDHOSTS "$HOSTSELECTION")"
		#F_SHOWHOSTS "checklist" "$HOSTSELEXPANDED"

		# LOCAL or GIT
		ENSRC=$(F_DIALOG --menu "\nChoose an option:" \
                        15 76 14 \
                        gitlab "(define an available app within your gitlab server)" \
                        local "(define and push a local file on this server to a target)" \
                        3>&1 1>&2 2>&3)
		
		case $ENSRC in
			local)
			unset SELAPPS
			# TODO: select apps then choose hosts
			SELAPPS=$(F_LOCSRC)
			
			# atm we have to use group otherwise we have to switch group_vars to targetgroup/host/ as well	
                	#SELHOSTS=$(F_SHOWHOSTS "checklist" "$HOSTSELEXPANDED")
	               	#HOSTSELEXPANDED="$(F_EXPANDHOSTS "$HOSTSELECTION")"
			# enable app for each target group
			for tapp in $SELAPPS;do
				F_WAITBOX "... linking $tapp ..."
				app_fulldir=$(find $REPODIR -type f -name $tapp |egrep "(tar|tgz|spl)")
				app_dir=${app_fulldir%/*}
				app_type=$(echo "$app_dir" | egrep -o '(/other$|/splunk$)')
				F_LOG $FUNCNAME "app_fulldir: $app_fulldir, app_dir: $app_dir, app_type: $app_type"
				if [ "$app_type" == "/other" -o "$app_type" == "/splunk" ];then
				    app_name="$(tar tf "$app_fulldir" 2> /dev/null |head -n1 |tr -d "/")"
				else
				    app_name=${app_dir##*/}
				    app_type="/${app_name}"
				fi
				for tgroup in $HOSTSELECTION;do
					F_GVARDIR $tgroup
					echo -e "will start playbook:\n$ABIN -i $HOSTFILE $PBENAPP -e \"app_name=$app_name app2group=$tgroup filename=$tapp git_url='' git_branch=''\":\n" >>$LOG
					$ABIN -i $HOSTFILE $PBENAPP -e "app_type=$app_type app_name=$app_name app2group=$tgroup filename=$tapp git_url='' git_branch=''" >> $LOG 2>&1
					[ $? -ne 0 ] && F_ERRLOG "1" "linking $app_name to $tgroup\n\n" "$LOG"
				done
			done
			F_ERRLOG 0 "Linking apps finished" "$LOG"
			;;
			gitlab)
			unset SELAPPS
			# check if settings are done already:
			if [ -f $GLABSETTINGS ];then
				. $GLABSETTINGS
			else
				F_SETUP_GITLAB
			fi
			# get gitlab projects
			F_DIALOG --begin 3 3 --infobox "\nPlease standby until all gitlab projects have been parsed..." 5 80
			SELAPPS=$(F_GITLABSRC|sort)
			unset OPTIONS
        		OPTIONS=($(echo "CUSTOM GIT-Project off" && for gapp in $SELAPPS;do echo ${gapp##*/} "GIT-Project" off; done))
		        GLABAPP=$(F_DIALOG --checklist "\nPlease use the space-bar to make your selection:" 80 80 70 "${OPTIONS[@]}" 2>&1 >/dev/tty)
                        for gapp in $GLABAPP;do
				if [ "$gapp" == "CUSTOM" ];then
					gapp=$(F_DIALOG --inputbox '\nHINT: the project MUST exists already on the gitlab server!\nType in the gitlab project name (only the name):\n' 15 100 2>&1 >>/dev/tty)
				fi
				F_GITLABSRC | grep $gapp >>/dev/null
				if [ $? -ne 0 ];then
					F_MSG "ERROR: > $gapp < does not exists on gitlab! Please create the repository first. This app will be SKIPPED."
				else
	                                app_full=$(echo "$SELAPPS" |tr " " "\n" |egrep "/${gapp}$")
	       	                        app_dir=${app_full%/*}
	       	                        app_namespace=${app_dir##*/}
					F_LOG $FUNCNAME "gapp: $gapp, app_full: $app_full, app_dir: $app_dir, appnamespace: $app_namespace" 
	       	                        for tgroup in $HOSTSELECTION;do
                                        F_GVARDIR $tgroup
						# TODO: may have an option for choosing branch?!
	                                        echo -e "will start playbook:\n$ABIN -i $HOSTFILE $PBENAPP -e \"app_name=$gapp app2group=$tgroup filename='' git_url=git@${GLABHOST}:${app_namespace} git_branch=''\":\n" >>$LOG
						F_A2BIN $HOSTFILE $PBENAPP "Enable App" "-e {'app_name':'$gapp','app2group':'$tgroup','filename':'','git_url':'git@${GLABHOST}:${app_namespace}','git_branch':'master'}"
						F_ERRLOG "$?" "linking $gapp to $tgroup\n\n" "$LOG"
	                                done
				fi
                        done
			;;
			*)
			echo NO SELECTION MADE..
			;;
		esac
	fi
	echo "$FUNCNAME finished" >> $LOG
}

# ask user and write settings to local file
F_SETUP_GITLAB(){
	echo "$FUNCNAME started" >> $LOG
	# ask for server
	# ask for personal token
	# write config if all is fine (only)
	unset GLABHOST PTOKEN ERRHOST ERRTOK
	F_DIALOG --msgbox "\n(Re-)Initializing gitlab authentication!\n" 10 80

	while [ -z "$GLABHOST" ];do
		GLABHOST=$(F_DIALOG --inputbox '\nType the FQDN/IP of your gitlab server here (no URL!):\n' 15 100 2>&1 >>/dev/tty)
		ERRHOST=$?
		[ "$ERRHOST" -ne 0 ]&& break
	done
	while [ -z "$PTOKEN" ]&&[ "$ERRHOST" -eq 0 ];do
		PTOKEN=$(F_DIALOG --inputbox '\nOpen your gitlab web GUI\n -> Open your profile settings\n -> Create a personal Access Token\n -> type that token here:\n' 25 100 2>&1 >>/dev/tty)
		ERRTOK=$?
		[ "$ERRTOK" -ne 0 ]&& break
	done
	# error out or write the config if not
	if [ "$ERRHOST" -ne 0 ]||[ "$ERRTOK" -ne 0 ];then
		F_DIAERR "host var: $ERRHOST,token var: $ERRTOK"
	else
		echo -e "GLABHOST=\"$GLABHOST\"\nPTOKEN=\"$PTOKEN\"" > $GLABSETTINGS
	fi
	echo "$FUNCNAME finished" >> $LOG
}


# get all available gitlab projects for the current user
# this does not work with other git servers (think of ssh git@git-server info for those supporting this)
F_GITLABSRC(){
	echo "$FUNCNAME started" >> $LOG
	# check of required vars are set
	# build gitlab URL
	# curl with the private token 
	# parse the result with python and grep for the wanted project URLs
	unset ERRC
	if [ ! -z "$PTOKEN" ]&&[ ! -z "$GLABHOST" ];then
		# TODO: check for curl as a req
		# TODO: check for python and python module json.tool as a req

		# I'm not that happy with this URL because it seems to be so unflexible for future changes (besides that parsing grep)
		# ... but: it works atm..
		# page=1 and per_page are required otherwise you will see the per page setting in the users settings only (default 20)
		GLABURL="https://$GLABHOST/api/v3/projects?simple=true&page=1&per_page=1000"

		# I prefer to use the private token instead of oauth
		curl -s --header "PRIVATE-TOKEN: $PTOKEN" "$GLABURL" | python -mjson.tool | sed 's/[\",]//g' | egrep "web_url:" |sed 's/\s*web_url:\s*//g'
	fi
	echo "$FUNCNAME finished" >> $LOG
}

# Just showing a simple message box with some dynamic info
F_MSG(){
	echo "$FUNCNAME started" >> $LOG
	# required arg: message
	MSG="$1"
	[ -z "$MSG" ]&& echo "FATAL: missing req arg in $FUNCNAME! ABORTED!" && F_EXIT
	F_DIALOG --msgbox "$MSG" 10 100
	echo "$FUNCNAME finished" >> $LOG
}

# updating target dirs based on the template dir
# this ensures consistent tasks for all config folders
F_TPLUPDATE(){
	echo "$FUNCNAME started" >> $LOG
	# required argument: targetgroup/hostname
	unset ROLEPATH
	
	FRPATH="$1"
	ROLEPATH="$2"

	if [ -z "$ROLEPATH" ]||[ ! -d "$FRPATH" ];then
		echo "FATAL: missing req arg in $FUNCNAME! $ROLEPATH and $FRPATH. ABORTED!" && F_EXIT
	fi

	if [ -d $FRPATH/$ROLEPATH ];then
		for i in $ROLEPATH;do
			cp -av $FRPATH/template/* $FRPATH/$i/ >>$LOG
			[ $? -ne 0 ]&&echo "FATAL: Cannot copy template to $FRPATH/$i/ !" && F_EXIT
		done
	else
		F_MSG "\nERROR: cannot find specified path: $ROLEPATH!"
	fi
	echo "$FUNCNAME finished" >> $LOG
}

# updating target dirs based on the APP template dir
# this ensures consistent tasks for all config folders
F_APPTPLUPDATE(){
        echo "$FUNCNAME started" >> $LOG
        # required argument: targetgroup/hostname
        unset ROLEPATH FRPATH

        FRPATH="$1" # roles/apps/app.template
        ROLEPATH="$2" # roles/apps/TA-xxxxxxxxxxxxxxxxxx-dsl

        #FRPATH="roles/system"

        if [ -z "$ROLEPATH" ]||[ ! -d "$FRPATH" ];then
                echo "FATAL: missing req arg in $FUNCNAME! $ROLEPATH and $FRPATH. ABORTED!" && F_EXIT
        fi

        cp -av $FRPATH/* $ROLEPATH/ >>$LOG
        [ $? -ne 0 ] && echo "FATAL: Cannot copy template to $ROLEPATH/ !" && F_EXIT
        echo "$FUNCNAME finished" >> $LOG
}

# pull system/local configs for remote server
F_PULLSYSC(){
	echo "$FUNCNAME started" >> $LOG
	ABORTED=0
	AUTO="$1"
	if [ -z "$AUTO" ];then
		[ -z "$HOSTFILE" ]&& F_HOSTFILE
		unset HOSTSELEXPANDED ABORTED SYScDIR HOSTSELECT HOSTSELECTION
       		while [ -z "$HOSTSELECT" ];do
			HOSTSELECTION=$(F_TARGETS radiolist)
			[ $HOSTSELECTION == "ABORTED" ] && ABORTED=1 && break
       	        	if [ -z "$HOSTSELECTION" ];then
       	              		F_DIALOG --msgbox "ERROR: no selection made. Choose 1 or more targets with space bar." 10 30
       	          	else
       	              		HOSTSELECT=1
			     	ABORTED=0
       	          	fi
        	done
	fi

	if [ "$ABORTED" -ne 0 ];then
		echo "$FUNCNAME: aborted by user." >>$LOG
		echo ABORTED
	else
		if [ -z "$AUTO" ];then
			HOSTSELEXPANDED=$(F_EXPANDHOSTS "$HOSTSELECTION")
			[ "$HOSTSELEXPANDED" == "ERROR" ]&& echo "FATAL: problem with expanding hosts for $HOSTSELECTION" && F_EXIT
			[ "$HOSTSELEXPANDED" == "EMPTY" ]&& F_LOG $FUNCNAME "Warning $HOSTSELECTION is empty?!"
		else
			HOSTSELEXPANDED="$AUTO"
		fi

		# set temporarly to always pull.
		# TODO: decide to make this configurable as a general user defined setting
		#ANS=$(F_SSHORNOT)
		ANS=Pull

		case "$ANS" in
			ABORTED)
			# return abort state
			echo ABORTED
			break
			;;
			DANGEROUS-Skip)
			echo SKIPPED
			;;
			DANGEROUS-Import|Pull)
	  		    for host in $(echo "$HOSTSELEXPANDED"| cut -d : -f1);do
				OWNDIR=$HOSTSELECTION/$host
				SYScDIR=roles/system/$OWNDIR
				if [ ! -d "$SYScDIR/files" ];then
				    mkdir -p "$SYScDIR"
		    		    TPLMSG="Base directory structure created!"
				else
				    TPLMSG="Target dir exists already. Skipped copying template skeleton!"
				fi
	
				# this initiates the template files but also ensures that we keep all tasks and stuff current!
				F_TPLUPDATE "roles/system" $OWNDIR
	
				# do stuff based on user selection
				if [ "$ANS" == "DANGEROUS-Import" ];then
				   SELDIR=$(F_DBROWSE "$host" /TYPE-IN-LOCAL-DIR)
				   [ "$SELDIR" == "999" ] && echo "breakout!" && break
				   while [ ! -d "$SELDIR" ]&&[ "$SELDIR" -ne 999 ];do
					F_DIALOG --msgbox "ERROR:\n\nThe path you entered is not a directory!" 10 50
					SELDIR=$(F_DBROWSE $host /TYPE-IN-LOCAL-DIR)
				   done
				   [ "$SELDIR" == "999" ] && break
				else
				    if [ ! -z "$REMDIR" ];then
					REMPATH="$REMDIR"
				    else
					REMPATH="/opt/splunk/etc/system/local"
				    fi
				    # disabled user conf temporarly
				    # TODO: put this into a general setting store instead?
				    #REMDIR=$(F_DBROWSE "$host" "$REMPATH")
				    REMDIR=$REMPATH

				    echo "$FUNCNAME remdir: $REMDIR" >> $LOG
				    if [ "$REMDIR" == "999" ];then
					echo "$FUNCNAME: aborted!" >> $LOG
					ABORTED=1
				    else
					    SELDIR="/tmp/$host"
					    SCPERR=$(F_DIMPORT $host "$REMDIR" "$SELDIR")
					    echo "$FUNCNAME: SCPERR was $SCPERR" >> $LOG
					    [ $SCPERR -ne 0 ]&& F_MSG "ERROR: Problem while importing from >$host<"
				    fi
				fi
				if [ "$ABORTED" != "1" ];then
					F_VALCONF "$SELDIR"
					F_CLEANCONF "$SELDIR"
					# again! because clean could had cleaned all..
					F_VALCONF "$SELDIR"
					cp -v $SELDIR/*.conf $SYScDIR/system_local_configs/files/system/local/ >> $LOG
					CPERR=$?
					echo "$FUNCNAME: CPERR was $CPERR" >> $LOG
					# ask if you want to manage all files or a subset only
					#F_ASKMANAGE "$SYScDIR"
				fi
			    done
			    if [ "$SELDIR" != "999" ]&&[ "$ABORTED" != "1" ];then
				echo "$FUNCNAME: not aborted" >> $LOG
				if [ $CPERR -eq 0 ]&&[ $SCPERR -eq 0 ] ;then
					echo "$FUNCNAME: all files copied fine" >> $LOG
					#F_DIALOG --msgbox "DONE:\n\nAll files copied successfully." 15 80
				else
					echo "$FUNCNAME: ERROR: A problem occurred while copying your source files" >> $LOG
					echo "ERROR"
					#F_DIALOG --msgbox "ERROR:\n\nA problem occurred while copying your source files!" 10 50
				fi
			    else
				echo "$FUNCNAME: ABORTED" >> $LOG
				echo "ABORTED"
			    fi
			;;
			*) # this should never happen
			echo "$FUNCNAME - ERROR: No valid arg for case ($ANS)" >> $LOG
			echo "$FUNCNAME:ERROR"
			F_EXIT
			;;
		esac
	fi
	echo "$FUNCNAME finished" >> $LOG
}

# show hostnames in an expanded target group
F_SHOWHOSTS(){
	F_LOG $FUNCNAME "started"
	unset OPTIONS HTARGETS HOSTSELEXPANDED host ABORTED DIAOPT
	DIAOPT="$1"
	HOSTSELEXPANDED="$2"
	[ -z "$DIAOPT" ]&& echo "ABORTED! Missing arg for dialog in $FUNCNAME!" && F_EXIT
	[ -z "$HOSTSELEXPANDED" ]&& echo "ABORTED! Missing arg for target group in $FUNCNAME!" && F_EXIT

	OPTIONS=($(for host in $HOSTSELEXPANDED;do echo "$host $host off";done))

        while [ -z "$HTARGETS" ];do
	      ABORTED=0
              HTARGETS=$(F_DIALOG --${DIAOPT} "\nThe following are members of the choosen target group(s)\n<$HOSTSELECTION>\n\nMake your selection:" 30 80 50 "${OPTIONS[@]}" 2>&1 >/dev/tty)
              [ $? -eq 1 ] && ABORTED=1 && break
	      F_LOG $FUNCNAME "HTARGETS (while): >$HTARGETS<"
        done
	F_LOG $FUNCNAME "HTARGETS (end): $HTARGETS"
	F_LOG $FUNCNAME "finished"
	# return host objects to the calling function
	[ "$ABORTED" -eq 0 ] && echo "$HTARGETS"
}

# show available enviroments to the user and let the user select one
F_CHOOSEENV(){
	# returns the choosen environment so call this function like:
	# ENVCHOICE="$(F_CHOOSEENV)"
	F_LOG $FUNCNAME "started"

        OPTIONS=($(for inv in $(find $AINVENTORY/* -maxdepth 0 -type d);do echo "${inv##*/} $inv off";done))

        while [ -z "$ENVTARGET" ];do
              ABORTED=0
              ENVTARGET=$(F_DIALOG --radiolist "\nYou HAVE TO choose an environment first.\n\nThe following are the available environment(s) based on\n<$AINVENTORY>\n\nMake your selection:" 30 80 30 "${OPTIONS[@]}" 2>&1 >/dev/tty)
              [ $? -eq 1 ] && ABORTED=1 && break
              F_LOG $FUNCNAME "ENVTARGET (while): >$ENVTARGET<"
        done
        F_LOG $FUNCNAME "ENVTARGET (end): $ENVTARGET"
        F_LOG $FUNCNAME "finished"
        # return objects to the calling function
        [ "$ABORTED" -ne 0 ] && ENVTARGET="ABORTED"
	echo "$ENVTARGET"
}

# manage local conf files 
F_EDITSYSC(){
	echo "$FUNCNAME started" >> $LOG
        unset HOSTSELEXPANDED ABORTED SYScDIR HOSTSELECT EDITHOST host
	F_HOSTFILE
        while [ -z "$HOSTSELECT" ];do
                HOSTSELECTION=$(F_TARGETS radiolist)
		if [ "$HOSTSELECTION" == "ABORTED" ];then
			ABORTED=1 && break
		else
                 	if [ -z "$HOSTSELECTION" ];then
                     		F_DIALOG --msgbox "ERROR: no selection made. Choose a target with space bar." 10 30
                 	else
                     		HOSTSELECT=1
                     		ABORTED=0
                 	fi
		fi
        done
        if [ "$ABORTED" -eq 1 ];then
                echo "$FUNCNAME: aborted by user." >> $LOG
        else
		HABORTED=0
		while [ $HABORTED -ne 1 ];do
			#TODO: ask if the user want to edit/open a path or manage previously pulled conf files
			# e.g. to say for the shc group do not manage authorize.conf

			HOSTSELEXPANDED=$(F_EXPANDHOSTS "$HOSTSELECTION" |cut -d : -f1)
			EDITHOST="$(F_SHOWHOSTS radiolist "$HOSTSELEXPANDED")"
			[ $? -eq 1 ] && HABORTED=1 && break

			PERR=$(F_PULLSYSC $EDITHOST)
			[ "$PERR" == "ABORTED" -o "$PERR" == "ERROR" ] && HABORTED=1 && unset SELECTION &&break 
			
			echo "$FUNCNAME: Continuing after pull selection ($PERR)" >> $LOG

			SYSDIR=roles/system/$HOSTSELECTION/$EDITHOST/system_local_configs/files/system/local
			unset OPTIONS
       			OPTIONS=($(for hostfile in $(find $SYSDIR -type f) ;do echo "${hostfile##*/}" "file";done|sort -f))
		        while [ -z "$FTARGET" ];do
				unset DIROPENED
        	      		FTARGET=$(F_DIALOG --colors --extra-button --extra-label "Open directory" --cancel-label "Finish" --menu "\nThe following are files currently active for the given host\n\n\Zb\Z1<$EDITHOST>\Zn\n\nChoose one file for editing:" 30 80 30 "${OPTIONS[@]}" 2>&1 >/dev/tty)
				FERR=$?
				if [ $FERR -eq 1 ];then
					ABORTED=1
					unset FTARGET && break
				else
					# if the user uses the extra button we open a dir on CLI
					if [ $FERR -eq 3 ];then
						DIROPENED=1
						unset FTARGET
						clear
						echo -e "\n\nSwitching to directory: $SYSDIR"
						echo -e "\n***********************************************************************"
						echo -e "** Go back by typing <exit> or <CTRL+D>"
						echo -e "***********************************************************************\n"
						bash --rcfile <(echo "PS1=\"$EDITHOST/system/local \$>\";cd $SYSDIR/ && ls -la")
					else
						if [ -z "$FTARGET" ];then
               	           		      F_DIALOG --msgbox "ERROR: no selection made. Choose a file." 10 30
			                                ABORTED=1
               				        else
               	             			#FTARGET=1
			                                ABORTED=0
               	 		        fi
					fi
				fi
				# open file for editing
				if [ "$ABORTED" -eq 0 ]&&[ -z "$DIROPENED" ]&&[ "$HABORTED" -ne 1 ];then
					if [ -f $SYSDIR/${FTARGET} ];then
						$EDITBIN $SYSDIR/${FTARGET}
					else
						F_DIALOG --msgbox "NO FILES THERE?! Directory seems to be empty try a pull first" 10 30
						break
					fi
					unset FTARGET
				fi	
        		done
		done
	fi
	echo "$FUNCNAME finished" >> $LOG
}

# abort current menu and go back to MAIN dialog
F_ABORTMAINMENU(){
	F_LOG "$FUNCNAME" "started with $MAINMENU"
	$MAINMENU
	F_LOG "$FUNCNAME" ended
}

# shelper gui
F_SHELPER(){
	F_LOG "$FUNCNAME" started
 	while [ "$MENUDONE" == "0" ]; do
		SELECTION=$(F_DIALOG --ok-label "Select Entry" --cancel-label "Exit" \
			--menu "\nshelper the splunk helper tool.\n\nSelect an option:" \
			15 100 15 \
			"" "" \
			"Upgrade/Install" "Will install or upgrade shelper on given machines" \
			Exec "Will execute certain shelper commands on given machines" \
			"" "" \
			"" "" \
			3>&1 1>&2 2>&3)
		if [ "$?" != "0" ]; then
		    MENUDONE=1
		    echo "$0: finished."
		    F_EXIT
		fi
		case "$SELECTION" in
			"Upgrade/Install")
			F_SHUPGRADE
			;;
			Exec)
			F_SHEXEC
			;;
		esac
	done
}

# calculate a temporary group based on user selected values
F_CALCTGROUP(){ F_LOG "$FUNCNAME" started
	# returns: N/A
	# requires: tempfile name as arg1

	[ -z $1 ] && echo "ERROR: missing arg1" && F_EXIT
	CALCGRPF=${AINVENTORY}/${TARGETENV}/$1

        unset HOSTSELEXPANDED ABORTED HOSTSELECT HOSTFILE tgroup
        F_HOSTFILE
        while [ -z "$HOSTSELECT" ];do
                HOSTSELECTION=$(F_TARGETS checklist)
                if [ "$HOSTSELECTION" == "ABORTED" ];then
                        ABORTED=1 && break
			[ $? -ne 0 ] && F_ABORTMAINMENU
                else
                        if [ -z "$HOSTSELECTION" ];then
                                F_DIALOG --msgbox "ERROR: no selection made. Choose a target with space bar." 10 30
                        else
                                HOSTSELECT=1
                                ABORTED=0
                        fi
                fi
        done
	[ $ABORTED -eq 1 ] && F_ABORTMAINMENU

	# ask for specific hosts or target group?
	unset HOSTLIST['expanded']
	F_DIALOG --begin 3 3 --infobox "\nPlease standby until all hostnames from your target groups are generated" 5 80
	for hostlist in $HOSTSELECTION;do
		if [ -z "${HOSTLIST['expanded']}" ];then
			HOSTLIST['expanded']+="$(F_EXPANDHOSTS $hostlist | grep -v EMPTY)"
		else
			HOSTLIST['expanded']+=" $(F_EXPANDHOSTS $hostlist | grep -v EMPTY)"
		fi
	done

	unset EDITHOST	
	while [ -z "$EDITHOST" ];do
	        EDITHOST=$(F_SHOWHOSTS checklist "${HOSTLIST['expanded']}")
		if [ -z "$EDITHOST" ];then
			F_DIALOG --yesno "No selection made! Retry?" 10 40
			[ $? -ne 0 ] && F_ABORTMAINMENU
		fi
	done

	# make host list unique to avoid duplicated upgrades when a host is in multiple groups
	# number each entry,sort by name and remove dups, sort by num
	CALCEDHOSTS=$(echo "$EDITHOST" | tr ' ' '\n' | nl| sort -u -k2|sort -n| cut -f2-|tr '\n' ' ')
	CALCEDHOSTST="$(echo "$CALCEDHOSTS" | sed 's/ /\\n/g')"
	UPGRADEHOSTS=$(echo "$EDITHOST" | tr ' ' '\n' | nl| sort -u -k2|sort -n| cut -f2-|tr '\n' ' ')
	UPGRADEHOSTST="$(echo "$UPGRADEHOSTS" | sed 's/ /\\n/g')"

	F_LOG "$FUNCNAME" "Will do action on: <$CALCEDHOSTS>"
	[ $? -ne 0 ] && F_ABORTMAINMENU

	# create a temporary ansible group (must be in the correct env path! otherwise varibles cant be found)
	echo '[aetmpgrp]' > $CALCGRPF
	for h in $CALCEDHOSTS;do echo "$h" >> $CALCGRPF; done
	F_LOG "$FUNCNAME" "Temporary group: $(cat $CALCGRPF)"
}

# splunk action
F_SPLACT(){ F_LOG "$FUNCNAME" started
	# will exec a (predefined) splunk action/task/command
	# splunk_action=X (where X must be defined in common/handlers)

	unset SPLEXE

	while [ -z "$SPLEXE" ];do
		SPLEXE=$(F_DIALOG --radiolist "\nChoose your splunk action:\n \
		(use the space-bar to select)" 15 100 5 \
			stop "stop splunk>" off \
			start "start splunk>" off \
			restart "restart splunk>" off \
			2>&1 >/dev/tty)
		ERR=$?
		echo "$FUNCNAME: err was $ERR" >> $LOG
		if [ $ERR -ne 0 ];then
			F_LOG "$FUNCNAME" "ABORTED due to err $ERR"
			F_ABORTMAINMENU
		fi
	done

	# calc temp hosts file
	F_CALCTGROUP splacthosts 

        F_LOG $FUNCNAME "python path before: $PYTHONPATH"
        export PYTHONPATH=${A2PATH}/lib
	export PYTHONUNBUFFERED=1
        F_LOG $FUNCNAME "python path after: $PYTHONPATH"

	$A2BIN -i "${AINVENTORY}/${TARGETENV}/splacthosts" "$PBSPLACT" --limit aetmpgrp -e "{'splunk_user':'$SPLUSR','splunk_password':'$SPLPW','splunk_action':'$SPLEXE'}" 2>&1 \
		| tee -a $LOG \
		| sed -u -r 's/(.*DEPRECATION.*)//Ig' \
		| F_DIALOG --scrollbar --colors --progressbox "\\Za\\Z1running splunk $SPLEXE on $CALCEDHOSTS ...\\Z\\n" 1000 1000
        F_ERRLOG "${PIPESTATUS[0]}" "splunk $SPLEXE for:\n\n$CALCEDHOSTST" "$LOG"

	F_LOG "$FUNCNAME" ended
	F_MENUMAIN
}

# shelper execute
F_SHEXEC(){ F_LOG "$FUNCNAME" started
	# splunk_user=
	# splunk_password=
	# shelper_action='reload custom'
	# shelper_custom='panels'

	CREDS=$(F_GETAPICREDS)
	SPLUSR="${CREDS/:*}"
	SPLPW="${CREDS/*:}"

	unset ANS

	while [ -z "$ANS" ];do
		ANS=$(F_DIALOG --radiolist "\nChoose your shelper action:\n \
		(use the space-bar to select)" 15 100 5 \
			reload-all "shelperreload all - so a full debug refresh" on \
			custom-reload "define your own reload command" off \
			2>&1 >/dev/tty)
		ERR=$?
		echo "$FUNCNAME: err was $ERR" >> $LOG
		if [ $ERR -ne 0 ];then
			echo "$FUNCNAME: err was $ERR" >> $LOG
			ANS="ABORTED"
		fi
		# reset ans when the user has selected the hint text...
		[ "$ANS" == "----" ]&&unset ANS
	done

	# calc temp hosts file
	F_CALCTGROUP shelperhosts 
		
	case $ANS in 
		custom-reload)
			unset SHCUST
			while [ -z "$SHCUST" ];do
                	  SHCUST=$(F_DIALOG --inputbox '\n\nType your custom reload arguments (space separated).\ne.g. "props panels transforms inputs"' 20 100 "" 2>&1 >/dev/tty)
                	  [ $? -ne 0 ] && F_ABORTMAINMENU
        		done
			SHEXE="reload custom"
			#SHCUST=$(echo $SHCUSTRAW | sed 's/ /SPACE/g')
		;;
		reload-all)
			SHEXE="reload all"
		;;
		*)	# TODO: do not exit but go to MAIN
			F_LOG $FUNCNAME "no answer given! aborted!"
			F_EXIT
		;;
	esac

        F_LOG $FUNCNAME "python path before: $PYTHONPATH"
        export PYTHONPATH=${A2PATH}/lib
	export PYTHONUNBUFFERED=1
        F_LOG $FUNCNAME "python path after: $PYTHONPATH"

	$A2BIN -i "${AINVENTORY}/${TARGETENV}/shelperhosts" "$PBSHRELOAD" --limit aetmpgrp -e "{'splunk_user':'$SPLUSR','splunk_password':'$SPLPW','shelper_action':'$SHEXE','shelper_custom':'$SHCUST'}" 2>&1 \
		| tee -a $LOG \
		| sed -u -r 's/(.*DEPRECATION.*)//Ig' \
		| F_DIALOG --scrollbar --colors --progressbox "\\Za\\Z1shelper running with $SHEXE $SHCUST on $UPGRADEHOSTS ...\\Z\\n" 1000 1000
        F_ERRLOG "${PIPESTATUS[0]}" "$SHEXE $SHCUST for:\n\n$UPGRADEHOSTST" "$LOG"

	F_MENUMAIN
}

# install/upgrade/use shelper
F_SHUPGRADE(){
        echo "$FUNCNAME started" >> $LOG
        unset HOSTSELEXPANDED ABORTED HOSTSELECT HOSTFILE tgroup
        F_HOSTFILE
        while [ -z "$HOSTSELECT" ];do
                HOSTSELECTION=$(F_TARGETS checklist)
                if [ "$HOSTSELECTION" == "ABORTED" ];then
                        ABORTED=1 && break
			[ $? -ne 0 ] && F_ABORTMAINMENU
                else
                        if [ -z "$HOSTSELECTION" ];then
                                F_DIALOG --msgbox "ERROR: no selection made. Choose a target with space bar." 10 30
                        else
                                HOSTSELECT=1
                                ABORTED=0
                        fi
                fi
        done
	[ $ABORTED -eq 1 ] && F_ABORTMAINMENU

	PLPW=""
	SPLPWR=fail

	# ask for specific hosts or target group?
	unset HOSTLIST['expanded']
	F_DIALOG --begin 3 3 --infobox "\nPlease standby until all hostnames from your target groups are generated" 5 80
	for hostlist in $HOSTSELECTION;do
		if [ -z "${HOSTLIST['expanded']}" ];then
			HOSTLIST['expanded']+="$(F_EXPANDHOSTS $hostlist | grep -v EMPTY)"
		else
			HOSTLIST['expanded']+=" $(F_EXPANDHOSTS $hostlist | grep -v EMPTY)"
		fi
	done

	unset EDITHOST	
	while [ -z "$EDITHOST" ];do
	        EDITHOST=$(F_SHOWHOSTS checklist "${HOSTLIST['expanded']}")
		if [ -z "$EDITHOST" ];then
			F_DIALOG --yesno "No selection made! Retry?" 10 40
			[ $? -ne 0 ] && F_ABORTMAINMENU
		fi
	done

	# make host list unique to avoid duplicated upgrades when a host is in multiple groups
	# number each entry,sort by name and remove dups, sort by num
	UPGRADEHOSTS=$(echo "$EDITHOST" | tr ' ' '\n' | nl| sort -u -k2|sort -n| cut -f2-|tr '\n' ' ')
	UPGRADEHOSTST="$(echo "$UPGRADEHOSTS" | sed 's/ /\\n/g')"

	F_LOG "$FUNCNAME" "Will upgrade/install shelper on: <$UPGRADEHOSTS>"
	F_DIALOG --scrollbar --yesno "Will upgrade/install shelper on these hosts:\n\n$UPGRADEHOSTST\n\nAre you sure?" 30 100
	[ $? -ne 0 ] && F_ABORTMAINMENU

	# create a temporary ansible group (must be in the correct env path! otherwise varibles cant be found)
	UTMPGRP=${AINVENTORY}/${TARGETENV}/shelperhosts
	echo '[tmpshmaint]' > $UTMPGRP
	for h in $UPGRADEHOSTS;do echo "$h" >> $UTMPGRP; done
	F_LOG "$FUNCNAME" "Temporary group: $(cat $UTMPGRP)"

 	F_LOG $FUNCNAME "F_A2BIN $UTMPGRP $PBSHINSTALL '--limit tmpshmaint" | tee -a $LOG

	# do it
	F_A2BIN "$UTMPGRP" "$PBSHINSTALL" "\Za\Z1UPGRADING/INSTALLING ...\Z\n" "--limit tmpshmaint" 
        F_ERRLOG "${PIPESTATUS[0]}" "shelper upgrade/install for:\n\n$UPGRADEHOSTST" "$LOG"
}

# ask for splunk_user and splunk_password vars
F_GETAPICREDS(){
	PLPW=""
	SPLPWR=fail

	while [ "$SPLPW" != "$SPLPWR" ];do
		[ -z "$PREUSR" ] && PREUSR=$DEFSPLAPIADMIN

		SPLUSR=$(F_DIALOG --inputbox '\n\nADMIN username for splunk API\n(only required for Indexer peer nodes - leave empty otherwise)' 20 100 $PREUSR 2>&1 >/dev/tty)
		[ $? -ne 0 ] && F_ABORTMAINMENU
		PREUSR=$SPLUSR
		SPLPW=$(F_DIALOG --passwordbox '\n\nADMIN password for splunk API\n(supports only these special chars for sure: -,_,%,@)\nYOU WILL SEE NOTHING WHILE TYPING!' 20 100 2>&1 >/dev/tty)
		[ $? -ne 0 ] && F_ABORTMAINMENU
		SPLPWR=$(F_DIALOG --passwordbox '\n\nTo verify the ADMIN password for splunk API write it again' 20 100 2>&1 >/dev/tty)
		[ $? -ne 0 ] && F_ABORTMAINMENU
		[ "$SPLPW" != "$SPLPWR" ] && F_DIAERR "3" "ERROR: Passwords doesn't match!"
	done

	[ -z "$SPLPW" ]&& SPLPW=undefined
	echo "$SPLUSR:$SPLPW"
}

# download and stage a splunk version
F_STAGESPL(){ F_LOG "$FUNCNAME started"
	# ask for version number
	# ask for version hash
	# stage it

#	group_vars/all/splunk_installation:
#	Answer for:	globversion: "6.5.5"
#			globhash: "586c3ec08cfb"
#	replace those vars and download
	F_HOSTFILE
	
	echo "$ABIN -i $HOSTFILE stage_splunk.yml -e \"globversion=$splver globhash=$splhash\""
}

# upgrading splunk cluster env
F_UPGRADESPLC(){ F_LOG $FUNCNAME started
	# ask:
	#   test? -> Major release? then: no splunk offline!
	#
	#   Upgrade all tiers at once?
	# 	Stop the master.
	#	Stop all the peers and search heads. 
	#	When bringing down the peers, use the splunk stop command, not splunk offline.
	#	Upgrade the master node, following the normal procedure for any Splunk Enterprise upgrade, as described in How to upgrade Splunk Enterprise in the Installation Manual. 
	#	Do not upgrade the peers yet.
	#	Start the master
	#	Run splunk enable maintenance-mode on the master. 
	#	To confirm that the master is in maintenance mode, run splunk show maintenance-mode
	#	Upgrade the peer nodes and search heads, following the normal procedure for any Splunk Enterprise upgrade, as described in How to upgrade Splunk Enterprise in the Installation Manual. 
	#	Start the peer nodes and search heads
	#	Run splunk disable maintenance-mode on the master. To confirm that the master is not in maintenance mode, run splunk show maintenance-mode.

	#   Upgrade each tier separately
	#	Upgrade the master node.
	#	Upgrade the search head tier:
	#		Stop all cluster members.
	#		Upgrade all members.
	#		Stop the deployer.
	#		Upgrade the deployer.
	#		Start the deployer.
	#		Start the members.
	#		Wait one to two minutes for captain election to complete. The cluster will then begin functioning.
	#	Upgrade the peer node tier
	#		Run splunk enable maintenance-mode on the master. 
	#		To confirm that the master is in maintenance mode, run splunk show maintenance-mode on the master. 
	#		Stop all the peer nodes. 
	#		When bringing down the peers, use the splunk stop command, not splunk offline.
	#		Upgrade the peer nodes, following the normal procedure for any Splunk Enterprise upgrade, as described in How to upgrade Splunk Enterprise in the Installation Manual.
	#		Start the peer nodes, if they are not already running.
	#		Run splunk disable maintenance-mode on the master.  

	# 1) MN
	# 2) SH cluster
	# 3) DEP
	# 4) Maintenance mode on
	# 5) IX cluster
	# 6) Maintenance mode off
	# 7) DS, DMC, HF, AI, LM, dev SH's
	# 8) specials: old AI (xxxxxxxxxxxxxxxxxx05), CDC SH
	# 

	F_LOG $FUNCNAME ended
}

## @fn F_SELHOST()
## @brief Show and choose host(s)
## @details Parsing the inventory, offering all groups found, parsing groups including childs, remove dups, offer host list and let the user choose
## @exception on abort: F_ABORTMAINMENU, on faulure: error dialog
F_SELHOST(){
        F_LOG $FUNCNAME started
        unset HOSTSELEXPANDED ABORTED HOSTSELECT HOSTFILE tgroup
        F_HOSTFILE
        while [ -z "$HOSTSELECT" ];do
                HOSTSELECTION=$(F_TARGETS checklist)
                if [ "$HOSTSELECTION" == "ABORTED" ];then
                        ABORTED=1 && break
                else
                        if [ -z "$HOSTSELECTION" ];then
                                F_DIALOG --msgbox "ERROR: no selection made. Choose a target with space bar." 10 30
                        else
                                HOSTSELECT=1
                                ABORTED=0
                        fi
                fi
        done
	if [ $ABORTED -eq 1 ];then
		F_ABORTMAINMENU
	else
			  # ask for specific hosts or target group?
			  unset HOSTLIST['expanded']
			  F_DIALOG --begin 3 3 --infobox "\nPlease standby until all hostnames from your target groups are generated" 5 80 2>&1 > /dev/tty
			  for hostlist in $HOSTSELECTION;do
				if [ -z "${HOSTLIST['expanded']}" ];then
					HOSTLIST['expanded']+="$(F_EXPANDHOSTS $hostlist | grep -v EMPTY)"
				else
					HOSTLIST['expanded']+=" $(F_EXPANDHOSTS $hostlist | grep -v EMPTY)"
				fi
			  done

			  unset EDITHOST	
			  while [ -z "$EDITHOST" ];do
			        EDITHOST=$(F_SHOWHOSTS checklist "${HOSTLIST['expanded']}")
				if [ -z "$EDITHOST" ];then
					F_DIALOG --yesno "No selection made! Retry?" 10 40
					[ $? -ne 0 ] && F_ABORTMAINMENU
				fi
			  done

			  # make host list unique to avoid duplicated upgrades when a host is in multiple groups
			  # number each entry,sort by name and remove dups, sort by num
			  # UPGRADEHOSTS=$(echo "$EDITHOST" | tr ' ' '\n' | nl| sort -u -k2|sort -n| cut -f2-|tr '\n' ' ')
			  echo "$EDITHOST" | tr ' ' '\n' | nl| sort -u -k2|sort -n| cut -f2-|tr '\n' ' '
	fi
}

## @fn F_INSTALLSPL()
## @brief Install splunk on ansible prepared servers
## @exception on abort: F_ABORTMAINMENU, on failure: F_ERRLOG dialog
F_INSTALLSPL(){
        F_LOG $FUNCNAME started
	# this installs pure splunk without configuration
	
        SHOSTS="$(F_SELHOST)"
        SHOSTST="$(echo "$SHOSTS" | sed 's/ /\n/g')"

        if  [ -z "$SHOSTS" ] || [ -z $SHOSTST ];then
                F_LOG $FUNCNAME "SHOSTS ($SHOSTS) or SHOSTST ($SHOSTST) empty"
                F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"
        else
                F_LOG $FUNCNAME "SHOSTS and SHOSTST are both set"
        fi
	
	F_LOG "$FUNCNAME" "Will install splunk on <$SHOSTS>"
	F_DIALOG --scrollbar --yesno "Will install Splunk on these hosts:\n\n$SHOSTST\n\nAre you sure?" 30 100
	[ $? -ne 0 ] && F_ABORTMAINMENU

	# create a temporary ansible group (must be in the correct env path! otherwise varibles cant be found)
	ITMPGRP=${AINVENTORY}/${TARGETENV}/${FUNCNAME}_hosts
	echo '[tmpgrp]' > $ITMPGRP
	for h in $SHOSTS;do echo "$h" >> $ITMPGRP; done
	if [ $? -ne 0 ];then F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"; F_ABORTMAINMENU;fi

	F_LOG "$FUNCNAME" "Temporary generated group: $(cat $ITMPGRP)"

 	F_LOG $FUNCNAME "F_A2BIN $ITMPGRP $PBINSTALL --limit tmpgrp"

	# doit
	F_A2BIN "$ITMPGRP" "$PBINSTALL" "\Za\Z1INSTALLING ...\Z\n" "--limit tmpgrp" 
        F_ERRLOG "${PIPESTATUS[0]}" "Installing splunk on:\n\n$SHOSTST" "$LOG"

	# cleanup
	[ -f $ITMPGRP ] && F_LOG $FUNCNAME "deleting temp hosts file: $(rm -vf $ITMPGRP 2>&1)"

        F_LOG $FUNCNAME ended
}

# Upgrade splunk
F_UPGRADESPL(){
        F_LOG $FUNCNAME started
	# Prepare new version?
	# -> Setup the configs
	# -> Show the current staged version
	# Ask for hostfile
	# Ask for hosts OR/AND target groups?
	# Use upgrade playbook
 
	UPGRADEHOSTS="$(F_SELHOST)"
	UPGRADEHOSTST="$(echo "$UPGRADEHOSTS" | sed 's/ /\n/g')"

	if  [ -z "$UPGRADEHOSTS" ] || [ -z $UPGRADEHOSTST ];then
		F_LOG $FUNCNAME "UPGRADEHOSTS ($UPGRADEHOSTS) or UPGRADEHOSTSST ($UPGRADEHOSTST) empty"
		F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"
	else
		F_LOG $FUNCNAME "UPGRADEHOSTS and UPGRADEHOSTST are both set"
	fi

	CREDS=$(F_GETAPICREDS)
	SPLUSR="${CREDS/:*}"
	SPLPW="${CREDS/*:}"

	F_LOG "$FUNCNAME" "Will upgrade <$UPGRADEHOSTS>"
	F_DIALOG --scrollbar --yesno "Will upgrade Splunk on these hosts:\n\n$UPGRADEHOSTST\n\nAre you sure?" 30 100
	[ $? -ne 0 ] && F_ABORTMAINMENU

	# create a temporary ansible group (must be in the correct env path! otherwise varibles cant be found)
	UTMPGRP=${AINVENTORY}/${TARGETENV}/upgrhosts
	echo '[tmpupgrade]' > $UTMPGRP
	for h in $UPGRADEHOSTS;do echo "$h" >> $UTMPGRP; done
	if [ $? -ne 0 ];then F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"; F_ABORTMAINMENU;fi

	F_LOG "$FUNCNAME" "Temporary upgrade group: $(cat $UTMPGRP)"

 	F_LOG $FUNCNAME "F_A2BIN $UTMPGRP $PBUPGRADE '--limit tmpupgrade -e \"splunk_user=$SPLUSR splunk_password=$SPLPW\"" | tee -a $LOG

	# upgrade
	F_A2BIN "$UTMPGRP" "$PBUPGRADE" "\Za\Z1UPGRADING ...\Z\n" "--limit tmpupgrade -e {'splunk_user':'$SPLUSR','splunk_password':'$SPLPW'}" 
        F_ERRLOG "${PIPESTATUS[0]}" "Upgrade for:\n\n$UPGRADEHOSTST" "$LOG"

        F_LOG $FUNCNAME ended
}

# Deploy Apps to specified targets
F_DEPLOYAPP(){
	# Ask for hostfile
	# update all apps based on template
	# re-create deploy playbook to reflect manual changes like deleting an app
	# Ask for target group(s) to deploy
	# Deploy
        echo "$FUNCNAME started" >> $LOG
        unset HOSTSELEXPANDED ABORTED HOSTSELECT HOSTFILE tgroup
        F_HOSTFILE
        while [ -z "$HOSTSELECT" ];do
                HOSTSELECTION=$(F_TARGETS checklist)
                if [ "$HOSTSELECTION" == "ABORTED" ];then
                        ABORTED=1 && break
                else
                        if [ -z "$HOSTSELECTION" ];then
                                F_DIALOG --msgbox "ERROR: no selection made. Choose a target with space bar." 10 30
                        else
                                HOSTSELECT=1
                                ABORTED=0
                        fi
                fi
        done
	if [ "$ABORTED" -eq 0 ];then
		for rolesapp in $(find roles/apps -maxdepth 1 -type d |egrep -v "(template|file|vars|tasks)");do
			F_APPTPLUPDATE "roles/apps/app.template/tasks" "$rolesapp/tasks"
		done
		F_LOG "$FUNCNAME" "Re-creating deployment playbook to reflect any manual changes.. "

		$ABIN -i $HOSTFILE ae_recreate_deploy.yml -e "target_env=$TARGETENV"
		
		# do not buffer stdout!!
		export PYTHONUNBUFFERED=1

		for tgroup in $HOSTSELECTION;do
			# CHECK first!
			F_LOG $FUNCNAME "will exec: $A2BIN --check -i $HOSTFILE $AINVENTORY/$TARGETENV/$PBDEPLAPP -e 'target=$tgroup accept_hostkey=true' --tags $tgroup"
			#$A2BIN --check -i $HOSTFILE $AINVENTORY/$TARGETENV/$PBDEPLAPP -e "target=$tgroup accept_hostkey=true" --tags $tgroup | tee -a $LOG
			#$A2BIN -i $HOSTFILE $AINVENTORY/$TARGETENV/$PBDEPLAPP -e "target=$tgroup accept_hostkey=true" --tags $tgroup 2>&1 | tee -a $LOG
			F_A2BIN $HOSTFILE $AINVENTORY/$TARGETENV/$PBDEPLAPP "Deploying <$tgroup>..." "-e {'target':'$tgroup','accept_hostkey':'true'} --tags $tgroup"
			F_ERRLOG "${PIPESTATUS[0]}" "<deploying apps to $tgroup>" "$LOG"
		done
	fi
}


## @fn F_CLUSTER()
## @brief Indexer cluster menu
## @exception When no valid answer given returning to MAIN menu
## @details Provides a menu for several cluster tasks 
F_CLUSTER(){
	unset SELECTION
	SELECTION=$(F_DIALOG --ok-label "Select Entry" --cancel-label "Exit" --colors \
                   --menu "\nSelect an option:" \
                    	35 70 35 \
                        '' '\Zb\ZuMaintenance\ZB\ZU'\
                        "" "" \
                        AddPeer "configure a peer to be part of an existing IX cluster" \
                        OfflinePeer "NOT-READY-YET" \
                        RemovePeer "NOT-READY-YET" \
                        "" "" \
                        "" "" \
                        3>&1 1>&2 2>&3)

        if [ "$?" != "0" ]; then
              MENUDONE=1
              F_LOG $FUNCNAME "aborted by user"
              F_ABORTMAINMENU
        else
                case "$SELECTION" in
                        AddPeer)
			F_ADDPEER
                        ;;
                        *)
                        F_ABORTMAINMENU
                        ;;
		esac
	fi
}

## @fn F_ADDPEER()
## @brief Configures a new peer to an existing indexer cluster
## @exception ..
## @details 
F_ADDPEER(){
        F_LOG $FUNCNAME started

	unset SHOSTS SHOSTST
        SHOSTS="$(F_SELHOST)"
        SHOSTST="$(echo "$SHOSTS" | sed 's/ /\n/g')"

        if  [ -z "$SHOSTS" ] || [ -z $SHOSTST ];then
                F_LOG $FUNCNAME "SHOSTS ($SHOSTS) or SHOSTST ($SHOSTST) empty"
                F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"
        else
                F_LOG $FUNCNAME "SHOSTS and SHOSTST are both set"
        fi

        F_LOG "$FUNCNAME" "Will configure indexer peernode on <$SHOSTS>"
        F_DIALOG --scrollbar --yesno "Will configure: \n\n$SHOSTST\n\nas indexer peernode(s). Are you sure?" 30 100
        [ $? -ne 0 ] && F_ABORTMAINMENU

        # create a temporary ansible group (must be in the correct env path! otherwise varibles cant be found)
        ITMPGRP=${AINVENTORY}/${TARGETENV}/${FUNCNAME}_hosts
        echo '[tmpgrp]' > $ITMPGRP
        for h in $SHOSTS;do echo "$h" >> $ITMPGRP; done
        if [ $? -ne 0 ];then F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"; F_ABORTMAINMENU;fi

        F_LOG "$FUNCNAME" "Temporary generated group: $(cat $ITMPGRP)"

        F_LOG $FUNCNAME "F_A2BIN $ITMPGRP $PBINSTALL --limit tmpgrp"

        # doit
        F_A2BIN "$ITMPGRP" "$PBCONFPEER" "\Za\Z1Configure ...\Z\n" "--limit tmpgrp"
        F_ERRLOG "${PIPESTATUS[0]}" "configuration as indexer peernode on:\n\n$SHOSTST" "$LOG"

        F_LOG $FUNCNAME ended	
}

# the main menu window in regular mode
F_MENUMAIN(){
	MENUDONE=0
 	    while [ "$MENUDONE" == "0" ]; do
		SELECTION=$(F_DIALOG --ok-label "Select Entry" --cancel-label "Exit" --colors \
			--menu "\nSelect an option:" \
			35 76 35 \
			'' '\Zb\ZuAPPS\ZB\ZU'\
			"" "" \
			Link-app "Link an app (local file or git project) to a group" \
			Deploy-apps "Deploy all active apps for a target group" \
			Show-apps "Show all already linked apps" \
			"" "" \
			'' '\Zb\Zusystem/local/*.conf\ZB\ZU'\
			"" "" \
			Edit-SYSC "Fetch/Edit/Show/Manage remote conf files" \
			Deploy-SYSC "Deploy enabled system configs"\
			"" "" \
			'' '\Zb\Zusplunk> Tasks\ZB\ZU' \
			"" "" \
			shelper	"Upgrade/Install/Use the shelper" \
			Stop/Start "stop, start, restart splunk>" \
			"" "" \
			'' '\Zb\Zusplunk> Maintenance\ZB\ZU' \
			"" "" \
			Upgrade	"existing splunk> instance(s)" \
			Install	"splunk> on blank server(s)" \
			Cluster "Indexer tasks" \
			"" "" \
			"" "" \
			3>&1 1>&2 2>&3)

			#UpgradeCluster "Upgrade a splunk> cluster (SH / IX)" \

		if [ "$?" != "0" ]; then
		    MENUDONE=1
		    echo "$0: finished."
		    F_EXIT
		fi
		case "$SELECTION" in
			New-app)
			;;
			Link-app)
			F_ENAPP
			;;
			Deploy-apps)
			F_DEPLOYAPP
			;;
			Disable-app)
			;;
			Show-apps)
			SELECTION=$(F_SELECTOR)
			F_GOAPPS
			;;
			Edit-SYSC)
			F_EDITSYSC
			;;
			Pull-SYSC)
			F_PULLSYSC
			;;
			Deploy-SYSC)
			#SELECTION=$(F_SELECTOR)
			F_DEPLSYSC "$(F_SELECTOR)"
			;;
			Upgrade)
			F_UPGRADESPL
			;;
			UpgradeCluster)
                        F_UPGRADESPLC
                        ;;
			Stop/Start)
			F_SPLACT
			;;
			shelper)
			F_SHELPER
			;;
			gitlab)
			F_SETUP_GITLAB
			;;
			Install)
			F_INSTALLSPL
			;;
			Cluster)
			F_CLUSTER
			;;
		esac
	     done
}

# the main menu window in testing mode
F_MENUTESTING(){
	    while [ "$MENUDONE" == "0" ]; do
		SELECTION=$(F_DIALOG --colors --ok-label "Select Entry" --cancel-label "Exit" \
			--menu "\nStart the ansible engine\n\n\Zb\Z1TESTING AREA - TESTING AREA - TESTING AREA\Zn\n\nSelect an option:" \
			25 76 25 \
			______________ "MANAGE APPS  ______________" \
			"" "" \
			New-local-app "UNFINISHED: Add a new splunk> app to the local repo" \
			Disable-app "UNFINISHED: Disable an app for a target group" \
			3>&1 1>&2 2>&3)
		if [ "$?" != "0" ]; then
		    MENUDONE=1
		    echo "$0: finished."
		    F_EXIT
		fi
		case "$SELECTION" in
			New-app)
			;;
			Disable-app)
			;;
		esac
	     done

}

# the main menu window in advanced mode
F_MENUADVANCED(){
	while [ "$MENUDONE" == "0" ]; do
                SELECTION=$(F_DIALOG --colors --ok-label "Select Entry" --cancel-label "Exit" \
                        --menu "\nStart the ansible engine\n\n\Zb\Z1ADVANCED AREA - ADVANCED AREA - ADVANCED AREA\Zn\n\nSelect an option:" \
                        20 76 20 \
                        ______________ "ADVANCED (no daily business)  ______________" \
                        "" "" \
                        Pull-SYSC "Fetch config for a target (if Edit-SYSC fails)"\
                        gitlab  "(Re-)Initialize gitlab server authentication"\
                        3>&1 1>&2 2>&3)
                if [ "$?" != "0" ]; then
                    MENUDONE=1
                    echo "$0: finished."
		    F_EXIT
                fi
                case "$SELECTION" in
                        Pull-SYSC)
                        F_PULLSYSC
                        ;;
                        gitlab)
                        F_SETUP_GITLAB
                        ;;
                esac
	done	
}

# ugly but efficient
echo "$@" |grep -q "\-\-help"
[ $? -eq 0 ]&& F_HELP && F_EXIT

echo "$@" |egrep -q "(noninteractive|batch|api)"
if [ $? -eq 0 ];then
   # enter batch mode
   # parse args
   while [ ! -z "$1" ];do
     case "$1" in
	-1) BABIN=$ABIN ;shift;;
	-2) BABIN=$A2BIN ; shift;;
        --batch|--noninteractive) shift;;
	-p|--play) BPLAY="$2"; shift 2;;
	-t|--target) TARGET="$2"; shift 2;;
        -i|--inventory) HOSTFILE="$2"; shift 2;;
	*) echo -e "ERROR unknown argument: $BPLAY\n"; F_HELP; F_EXIT ;;
     esac
   done
   # validate args
   for f in $HOSTFILE $BPLAY; do
	if [ ! -f $f ];then
	  echo "ERROR missing file: >$f<"
	  F_HELP
	  F_EXIT
	fi
   done
   [ -z "$TARGET" -o -z "$BABIN" -o -z "$BPLAY" -o -z "$HOSTFILE" ] && echo "ERROR: missing a required arg!" && F_HELP && F_EXIT 
   # run 
   echo "$BABIN -i $HOSTFILE $BPLAY -e \"target=$TARGET accept_hostkey=true\" --tags $TARGET"
else
    # interactive mode
    MENUDONE=0

    while [ ! -z "$1" ]; do
      case "$1" in
	--advanced)
	MAINMENU=F_MENUADVANCED
	shift
	;;
	--testing)
	MAINMENU=F_MENUTESTING
	shift
	;;
	--env)
	TARGETENV=$2
	shift 2
	;;
	*)
	F_HELP
	F_EXIT
	;;
      esac
    done
    # support multiple environments
    while [ -z "$TARGETENV" ];do
	TARGETENV=$(F_CHOOSEENV)
        [ "$TARGETENV" == "ABORTED" ] && F_EXIT
    done

    [ ! -d "$ADIR/inventories/$TARGETENV" ] && echo -e "\nERROR: specified environment $TARGETENV\n($ADIR/inventories/$TARGETENV)\ndoes not exist!" && F_HELP && F_EXIT
    [ -z "$MAINMENU" ]&& MAINMENU=F_MENUMAIN
    $MAINMENU
fi

F_EXIT
